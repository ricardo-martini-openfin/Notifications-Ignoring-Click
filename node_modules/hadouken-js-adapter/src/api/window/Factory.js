"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = require("../base");
const validate_1 = require("../../util/validate");
const Instance_1 = require("./Instance");
/**
 * @lends Window
 */
class _WindowModule extends base_1.Base {
    /**
     * Asynchronously returns a Window object that represents an existing window.
     * @param { Identity } identity
     * @return {Promise.<_Window>}
     * @tutorial Window.wrap
     * @static
     */
    async wrap(identity) {
        try {
            this.wire.sendAction('window-wrap');
        }
        catch (e) {
            // we do not want to expose this error, just continue if this analytics-only call fails
        }
        const errorMsg = validate_1.validateIdentity(identity);
        if (errorMsg) {
            throw new Error(errorMsg);
        }
        return new Instance_1._Window(this.wire, identity);
    }
    /**
     * Synchronously returns a Window object that represents an existing window.
     * @param { Identity } identity
     * @return {_Window}
     * @tutorial Window.wrapSync
     * @static
     */
    wrapSync(identity) {
        try {
            this.wire.sendAction('window-wrap-sync');
        }
        catch (e) {
            // we do not want to expose this error, just continue if this analytics-only call fails
        }
        const errorMsg = validate_1.validateIdentity(identity);
        if (errorMsg) {
            throw new Error(errorMsg);
        }
        return new Instance_1._Window(this.wire, identity);
    }
    /**
     * Creates a new Window.
     * @param { Window~options } options - Window creation options
     * @return {Promise.<_Window>}
     * @tutorial Window.create
     * @static
     */
    create(options) {
        try {
            this.wire.sendAction('create-window');
        }
        catch (e) {
            // we do not want to expose this error, just continue if this analytics-only call fails
        }
        const win = new Instance_1._Window(this.wire, { uuid: this.me.uuid, name: options.name });
        return win.createWindow(options);
    }
    /**
     * Asynchronously returns a Window object that represents the current window
     * @return {Promise.<_Window>}
     * @tutorial Window.getCurrent
     * @static
     */
    getCurrent() {
        try {
            this.wire.sendAction('get-current-window');
        }
        catch (e) {
            // we do not want to expose this error, just continue if this analytics-only call fails
        }
        if (!this.wire.me.isWindow) {
            throw new Error('You are not in a Window context');
        }
        const { uuid, name } = this.wire.me;
        return this.wrap({ uuid, name });
    }
    /**
     * Synchronously returns a Window object that represents the current window
     * @return {_Window}
     * @tutorial Window.getCurrentSync
     * @static
     */
    getCurrentSync() {
        try {
            this.wire.sendAction('get-current-window-sync');
        }
        catch (e) {
            // we do not want to expose this error, just continue if this analytics-only call fails
        }
        if (!this.wire.me.isWindow) {
            throw new Error('You are not in a Window context');
        }
        const { uuid, name } = this.wire.me;
        return this.wrapSync({ uuid, name });
    }
}
exports.default = _WindowModule;
