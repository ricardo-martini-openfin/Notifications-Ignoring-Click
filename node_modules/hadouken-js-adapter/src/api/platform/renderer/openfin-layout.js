"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* global GoldenLayout, $, document, ResizeObserver */
/* eslint-disable no-console */
/* eslint-disable no-underscore-dangle */
const base32 = require("hi-base32");
const resizable_view_1 = require("./resizable-view");
const utils_1 = require("./utils");
const commands_1 = require("./commands");
const Platform_1 = require("../../../shapes/Platform");
const view_pool_1 = require("./view-pool");
const CONTAINER_ID_PREFIX = 'container-';
const TAB_ID_PREFIX = 'tab-';
class LayoutManager {
    constructor(fin) {
        this.fin = fin;
        this.isDragging = false;
        this.resizing = false;
        this.showBackgroundImages = false;
        this.initManager = async () => {
            await this.createChannelConnections();
            this.setupDragDropRegions();
            this.setupWindowListeners();
            this.setupResizeObservers();
        };
        this.createLayout = (layout, container) => {
            this.setContainer(container);
            this.viewsResizeObserver.disconnect();
            this.layout = new GoldenLayout.GoldenLayout(layout, container);
            this.registerViewComponent();
            this.setupLayoutListeners();
            // this is the golden-layout init call
            this.layout.init();
        };
        this.setContainer = (container) => {
            this.container = container;
            this.containerResizeObserver.disconnect();
            this.containerResizeObserver.observe(this.container);
        };
        this.setupDragDropRegions = () => {
            let timeout;
            const handleDrag = (ev) => {
                const { originalEvent, type } = ev;
                const { settings } = this.layout.toConfig();
                const { sourceIdentity, settings: sourceSettings } = utils_1.getDragPayload(ev) || {};
                const { isSameApp, isSameWindow } = utils_1.compareIdentities(sourceIdentity, this.ofWindow.identity);
                if (!isSameApp || !(settings === null || settings === void 0 ? void 0 : settings.reorderEnabled)) {
                    originalEvent.dataTransfer.dropEffect = 'none';
                    return true;
                }
                const notAllowedDragIn = (sourceSettings === null || sourceSettings === void 0 ? void 0 : sourceSettings.preventDragOut) || settings.preventDragIn;
                if (isSameWindow || notAllowedDragIn) {
                    if (!isSameWindow) {
                        originalEvent.dataTransfer.dropEffect = 'none';
                    }
                    return false;
                }
                clearTimeout(timeout);
                timeout = null;
                if (type === 'dragenter' || type === 'dragover') {
                    this.isDragging = true;
                    if (!this.dragProxy) {
                        this.ofWindow.bringToFront();
                        utils_1.unmaximizeLayout(this.layout);
                        this.hideAllViews();
                        const newComponent = utils_1.createComponent({ name: 'internal-usage-to-be-replaced' });
                        const contentItem = this.layout.createContentItem(newComponent);
                        this.dragProxy = new this.layout._dragProxy(originalEvent.clientX, originalEvent.clientY, utils_1.mock, this.layout, contentItem, null);
                    }
                    else {
                        this.dragProxy._setDropPosition(originalEvent.clientX, originalEvent.clientY);
                    }
                }
                else if (type === 'dragleave') {
                    timeout = setTimeout(() => {
                        this.isDragging = false;
                        this.hideHighlight();
                        this.showViews();
                        this.dragProxy._contentItem._$destroy();
                        this.dragProxy = null;
                        const originWindow = this.fin.Window.wrapSync({
                            uuid: this.ofWindow.identity.uuid,
                            name: sourceIdentity.name
                        });
                        originWindow.bringToFront().catch(() => {
                            // do nothing, this can error out if the window name has capitalized letters... we should fix this at some point
                        });
                    }, 350);
                }
                return false;
            };
            $(document.body)
                .bind('dragenter', handleDrag)
                .bind('dragover', handleDrag)
                .bind('dragleave', handleDrag)
                .bind('drop', (ev) => {
                const winIdentity = this.ofWindow.identity;
                const { settings } = this.layout.toConfig();
                const { sourceIdentity, settings: sourceSettings } = utils_1.getDragPayload(ev) || {};
                const { isSameApp, isSameWindow } = utils_1.compareIdentities(sourceIdentity, this.ofWindow.identity);
                const notAllowedDragIn = (sourceSettings === null || sourceSettings === void 0 ? void 0 : sourceSettings.preventDragOut) || (settings === null || settings === void 0 ? void 0 : settings.preventDragIn);
                if (!isSameApp || isSameWindow || !(settings === null || settings === void 0 ? void 0 : settings.reorderEnabled) || notAllowedDragIn) {
                    if (this.dragProxy) {
                        this.dragProxy._contentItem._$destroy();
                        this.dragProxy = null;
                    }
                    return false;
                }
                if (this.dragProxy) {
                    this.dragProxy._onDrop();
                    this.dragProxy = null;
                }
                // This data placed on the drag event in the golden layouts code
                const identityArr = JSON.parse(ev.originalEvent.dataTransfer.getData('view-identity'));
                const viewConfig = JSON.parse(identityArr[0]);
                const createdComponent = this.getViewComponent({ name: 'internal-usage-to-be-replaced' });
                createdComponent.componentState = viewConfig;
                createdComponent.container.setState(viewConfig);
                // set the correct id and emit the correct events now that the internal placeholder has been replaced
                const containerDiv = createdComponent.container.getElement()[0];
                containerDiv.id = CONTAINER_ID_PREFIX + viewConfig.name;
                createdComponent.container.tab.element[0].id = TAB_ID_PREFIX + viewConfig.name;
                const viewIdentity = { uuid: winIdentity.uuid, name: viewConfig.name };
                utils_1.emitLocalEvent('container-created', viewIdentity, this.container);
                utils_1.emitLocalEvent('tab-created', viewIdentity, this.container);
                setTimeout(() => {
                    this.isDragging = false;
                    this.hideHighlight();
                    this.showViews();
                    this.platform.reparentView({ uuid: winIdentity.uuid, name: viewConfig.name }, winIdentity);
                }, 1);
                ev.stopPropagation();
                return false;
            });
        };
        this.replaceLayout = async (layout, container) => {
            const viewsInOldLayout = this.getViewComponents();
            viewsInOldLayout.forEach((viewState) => {
                const { componentState } = viewState;
                const ofView = this.getOfViewFromComponentState(componentState);
                ofView.removeAllListeners();
            });
            this.layout.destroy();
            this.createLayout(layout, container);
            const viewsInNewLayout = this.getViewComponents();
            viewsInOldLayout.forEach((view) => {
                if (!viewsInNewLayout.find((v) => v.componentState.name === view.componentState.name)) {
                    const ofView = this.getOfViewFromComponentState(view.componentState);
                    view_pool_1.detachOrCloseView(ofView).catch(console.error);
                }
            });
        };
        this.onViewDetached = async (event) => {
            const { viewIdentity, target } = event;
            try {
                // stop listening to div resizes if view is reparented
                const viewContainer = document.getElementById(CONTAINER_ID_PREFIX + viewIdentity.name);
                if (viewContainer &&
                    target &&
                    (target.name !== this.ofWindow.identity.name || target.uuid !== this.ofWindow.identity.uuid)) {
                    this.viewsResizeObserver.unobserve(viewContainer);
                }
            }
            catch (err) {
                console.error('Error on viewsResizeObserver unobserve:', err);
            }
            // Views not in a layout will keep the window alive
            const views = await this.ofWindow.getCurrentViews();
            if (views.length === 0) {
                // Close the window if this is the last view
                this.ofWindow.close();
            }
            else {
                await this.removeView(viewIdentity);
                this.updateButtonDisplay();
            }
        };
        this.setupLayoutListeners = () => {
            this.layout.on('tabCreated', this.onTabCreated);
            this.layout.on('stackCreated', this.onStackCreated);
            this.layout.on('itemCreated', this.onItemCreated);
            this.layout.on('initialised', this.onLayoutInit); // the typo here originates in golden-layout's code
            this.layout.on('tabCreated', async (tab) => {
                const { element, contentItem: { instance: { componentState: { name } } } } = tab;
                element[0].id = TAB_ID_PREFIX + name;
                // sometimes tab not yet attached to document, can not be found by id so nexttick before emitting
                await utils_1.delay(1);
                utils_1.emitLocalEvent('tab-created', { uuid: this.ofWindow.identity.uuid, name }, this.container);
            });
            this.layout.on('itemCreated', async (item) => {
                const { instance, isComponent } = item;
                if (isComponent) {
                    const { componentState: { name } } = instance;
                    // add id to element
                    const containerDiv = item.container.getElement()[0];
                    containerDiv.id = CONTAINER_ID_PREFIX + name;
                    // keep consistent with tab timing
                    await utils_1.delay(1);
                    utils_1.emitLocalEvent('container-created', { uuid: this.ofWindow.identity.uuid, name }, this.container);
                }
            });
        };
        this.onLayoutInit = () => {
            this.initializeLayoutViews();
            if (this.layout.config.settings.constrainDragToHeaders) {
                this.layout._$createRootItemAreas = () => {
                    /* This method originally creates drop areas on the far edges of window, e.g. far-right of window
                Since we want to avoid creating new stacks on drop, we don't need to create those areas */
                };
            }
        };
        this.registerViewComponent = () => {
            const { fin } = this;
            // WARNING: Do not try to use arrow function here, it breaks somewhere in golden-layout
            this.layout.registerComponent('view', function registerComponentCallback(container, componentState) {
                // ensure the component state has the uuid so we can wrap the views.
                componentState.uuid = fin.Application.getCurrentSync().identity.uuid;
                const containerDiv = container.getElement()[0];
                const openfinDefault = document.createElement('div');
                openfinDefault.className = 'openfin_default_background';
                containerDiv.appendChild(openfinDefault);
                return { componentState, container };
            });
        };
        this.setupWindowListeners = async () => {
            this.ofWindow.on('will-resize', () => {
                if (!this.resizing) {
                    this.resizing = true;
                    this.hideAllViews();
                }
            });
            this.ofWindow.on('bounds-changed', () => {
                if (this.resizing) {
                    this.layout.updateSize();
                    this.showViews();
                    this.resizing = false;
                }
            });
            this.ofWindow.on('view-detached', this.onViewDetached);
            this.ofWindow.on('view-target-changed', (payload) => {
                const { target, previousTarget, viewIdentity } = payload;
                if (previousTarget.name === target.name) {
                    return;
                }
                const viewComponent = this.getViewComponent(viewIdentity);
                this.setBackgroundImage(viewComponent);
            });
            this.ofWindow.on('hotkey', (e) => commands_1.handleWindowCommand(e, this));
            await this.ofWindow.on('options-changed', (payload) => {
                var _a;
                if ((_a = payload === null || payload === void 0 ? void 0 : payload.diff) === null || _a === void 0 ? void 0 : _a.showBackgroundImages) {
                    this.showBackgroundImages = !!payload.diff.showBackgroundImages.newVal;
                    if (this.showBackgroundImages) {
                        this.setBackgroundImages();
                    }
                    else {
                        const viewComponents = this.getViewComponents();
                        viewComponents.forEach((viewComponent) => {
                            const url = new URL(viewComponent.componentState.url);
                            utils_1.setContainerMessage(viewComponent.container, url.hostname);
                        });
                    }
                }
            });
            const { showBackgroundImages } = await this.ofWindow.getOptions();
            this.showBackgroundImages = !!showBackgroundImages;
        };
        this.setupResizeObservers = () => {
            this.containerResizeObserver = new ResizeObserver(utils_1.debounce(() => {
                if (!this.resizing) {
                    this.layout.updateSize();
                }
            }, 30, this.resizing));
            this.viewsResizeObserver = new ResizeObserver((entries) => {
                this.getViewComponents().forEach(this.updateViewVisibility);
                entries.forEach((entry) => {
                    const viewContainerId = entry.target.id;
                    const viewName = viewContainerId.substring(CONTAINER_ID_PREFIX.length);
                    const viewIdentity = { uuid: this.ofWindow.identity.uuid, name: viewName };
                    const ofView = this.fin.View.wrapSync(viewIdentity);
                    const boundingRect = entry.target.getBoundingClientRect();
                    utils_1.setViewBoundsByRect(boundingRect, ofView);
                });
            });
        };
        /**
         * Shows/hides a view depending on use case
         * @ignore
         */
        this.updateViewVisibility = (bv) => {
            const { height, width } = utils_1.getComponentBounds(bv);
            const maximizedContentItem = utils_1.getMaximizedContentItem(this.layout);
            const hasZeroBounds = height === 0 && width === 0;
            const isNonMaximizedView = maximizedContentItem && maximizedContentItem.container !== bv.container;
            const ofView = this.getOfViewFromComponentState(bv.componentState);
            if (this.isDragging || hasZeroBounds || isNonMaximizedView) {
                // not hiding on drag will break rearrangement functionality within window
                // hide on 0x0 bounds to trigger changes to document.visibilityState
                // hide views that aren't maximized if layout is in maximized state
                return ofView.hide();
            }
            return ofView.show();
        };
        this.onStackCreated = (stack) => {
            const controlsContainer = stack.header.controlsContainer[0];
            // Deal with overflow tabs indicator
            const additionalTabsButton = controlsContainer.getElementsByClassName('lm_tabdropdown')[0];
            additionalTabsButton.addEventListener('click', () => {
                const stackViews = stack.getComponentsByName('view');
                const originalFn = stack.header.tabDropdownContainer.hide.bind(stack.header.tabDropdownContainer);
                // be sure to re-show all the tabs when the tabdropdown container is hidden
                stack.header.tabDropdownContainer.hide = (...args) => {
                    originalFn(...args);
                    stackViews.forEach((info) => this.getOfViewFromComponentState(info.componentState).show());
                    stack.header.tabDropdownContainer.hide = originalFn;
                };
                stackViews.forEach((info) => this.getOfViewFromComponentState(info.componentState).hide());
            });
            stack.on('activeContentItemChanged', (newViewComponent) => {
                const state = newViewComponent.container.getState();
                const view = this.getOfViewFromComponentState(state);
                if (!this.isDragging) {
                    view.focus({ emitSynthFocused: false }).catch((e) => e); // view will error on startup if it's not yet created
                }
            });
            // GL calls this function internally in cases like creating a maximized layout
            const originalMaximize = stack.toggleMaximise;
            stack.toggleMaximise = () => {
                originalMaximize.call(stack);
                this.showViews(true);
            };
            const maximizeToggleButton = $(controlsContainer.querySelector('.lm_maximise'));
            maximizeToggleButton.on('click touchstart', () => this.showViews(true));
            if (stack.header.closeButton) {
                const closeStackButton = stack.header.closeButton.element;
                closeStackButton.off('click touchstart').on('click touchstart', () => this.onStackCloseClick(stack));
            }
            const popoutButton = controlsContainer.querySelector('.lm_popout');
            if (popoutButton) {
                // clone & replace to remove listeners
                const cleanButton = popoutButton.cloneNode(true);
                popoutButton.parentNode.replaceChild(cleanButton, popoutButton);
                $(cleanButton).on('click', () => this.onPopoutClick(stack));
            }
            if (this.layout.config.settings.constrainDragToHeaders) {
                const originalGetArea = stack._$getArea;
                // GL calls _$getArea when dragging to determine areas where a drop is possible
                stack._$getArea = () => {
                    const area = originalGetArea.call(stack);
                    // we want to prevent dropping on any areas of stack except its header
                    stack._contentAreaDimensions = {
                        header: stack._contentAreaDimensions.header
                    };
                    return area;
                };
            }
        };
        this.onTabCreated = (tab) => {
            this.isDragging = false;
            setTimeout(this.updateButtonDisplay, 10);
            if (tab._dragListener) {
                const dragListener = tab._dragListener;
                dragListener.on('dragStart', () => this.onTabDragStart(dragListener, tab));
                // TODO: remove once there's a build process for GL; a hack to access the function from GL
                dragListener._base32encode = base32.encode;
            }
            this.replaceCloseTabButton(tab);
            tab.element.off('mousedown touchstart').on('mousedown touchstart', (event) => {
                if (event.button === 0 || event.type === 'touchstart') {
                    this.isDragging = true;
                }
            });
            tab.element.on('mouseup touchend', (e) => this.onTabMouseUp(tab, e));
        };
        this.onTabMouseUp = (tab, event) => {
            if (event.button === 0 || event.type === 'touchstart') {
                this.isDragging = false;
                // focus on view when clicking on the active tab in the stack
                // we already focus on activeContentItemChanged but this case isn't captured there
                if (tab.header.activeContentItem === tab.contentItem) {
                    const ofView = this.getOfViewFromComponentState(tab.contentItem.container.getState());
                    ofView.focus({ emitSynthFocused: false });
                }
                // left mouse button or tap
                tab.header.parent.setActiveContentItem(tab.contentItem);
            }
            else if (event.button === 1 && tab.contentItem.container.getState().isClosable) {
                // close on middle mouse button
                this.onCloseTabButtonClick(tab);
            }
        };
        this.replaceCloseTabButton = (tab) => {
            tab.closeElement.off('click touchstart').on('click touchstart', () => this.onCloseTabButtonClick(tab));
        };
        this.onCloseTabButtonClick = async (tab) => {
            const state = tab.contentItem.container.getState();
            const view = this.getOfViewFromComponentState(state);
            this.platform.closeView(view.identity);
        };
        this.onPopoutClick = (stack) => {
            if (this.layout.config.settings.popoutWholeStack) {
                const stacksCount = this.layout.root.getItemsByType('stack').length;
                if (stacksCount > 1) {
                    const stackViews = stack.getComponentsByName('view');
                    const layout = {
                        ...this.layout.toConfig(),
                        ...utils_1.generateTabsPreset(stackViews, stack.config.activeItemIndex),
                        maximisedItemId: null
                    };
                    const activeOfView = this.getOfViewFromComponentState(stack.getActiveContentItem().container.getState());
                    stackViews.forEach((bv) => this.removeView(bv.componentState));
                    activeOfView.once('target-changed', () => {
                        activeOfView.focus();
                    });
                    this.platform.createWindow({ layout, reason: Platform_1.WindowCreationReason.Tearout });
                }
            }
            else {
                const currentTab = stack.getActiveContentItem().container.tab;
                commands_1.detachView(currentTab, this);
            }
        };
        this.onStackCloseClick = (stack) => {
            const stackViews = stack.getComponentsByName('view');
            stackViews.forEach((bv) => {
                const view = this.getOfViewFromComponentState(bv.componentState);
                this.platform.closeView(view.identity);
            });
        };
        // TODO: this shouldn't live here, but in standard-frame.
        this.updateButtonDisplay = () => {
            const views = this.getViewComponents();
            const viewCount = views.length;
            if (viewCount === 1) {
                $('.lm_close_tab').hide();
                $('.lm_close').hide(); // hide 'close stack' button
                $('.lm_popout').hide();
                $('.lm_maximise').hide();
            }
            else if (viewCount > 1) {
                $('.lm_popout').show();
                $('.lm_maximise').show();
                utils_1.showCloseButtonsIfClosable(this.layout);
            }
        };
        this.onItemCreated = async (item) => {
            try {
                // this needs to be delayed as the splitter and parent are not added to the item until the next tick
                await utils_1.delay(1);
                if (item.isColumn || item.isRow) {
                    item._splitter.forEach((s) => {
                        if (!s.viewEventsAdded) {
                            s.on('dragStart', this.hideAllViews, item);
                            s.on('dragStop', this.showViews, item);
                            s.viewEventsAdded = true;
                        }
                    });
                }
                else if (item.isStack && (item.parent.isRow || item.parent.isColumn)) {
                    item.parent._splitter.forEach((s) => {
                        if (!s.viewEventsAdded) {
                            s.on('dragStart', this.hideAllViews, item.parent);
                            s.on('dragStop', this.showViews, item.parent);
                            s.viewEventsAdded = true;
                        }
                    });
                }
            }
            catch (err) {
                console.error(err);
            }
        };
        this.handleOutOfWindowDrop = async (e, parentTab, dimensions) => {
            // CAUTION: if you make changes to this method, you might need to make similar changes to this.onPopoutClick
            // setTimeout to prevent removing tab before drag is complete
            await utils_1.delay(1);
            const viewState = parentTab.contentItem.container.getState();
            const ofView = this.getOfViewFromComponentState(viewState);
            const existingLayout = this.layout.toConfig();
            const newLayout = { ...existingLayout, ...utils_1.generateLayoutContent(viewState) };
            const { top, left, width, height } = utils_1.getOutOfWindowDropBounds(e, this.container, dimensions);
            const options = {
                defaultTop: top,
                defaultLeft: left,
                layout: newLayout
            };
            if (width && height) {
                options.defaultWidth = width;
                options.defaultHeight = height;
            }
            const viewCount = this.getViewComponents().length;
            if (viewCount > 1) {
                // Copy current customContext to new window
                // TODO: provide hook for user customization of default context
                options.customContext = await this.fin.Platform.getCurrentSync().getWindowContext();
                this.removeView(viewState);
                ofView.once('target-changed', (evt) => {
                    ofView.removeAllListeners();
                    ofView.focus();
                });
                this.platform.createWindow({ ...options, reason: Platform_1.WindowCreationReason.Tearout });
            }
            else {
                this.ofWindow.moveTo(left, top);
            }
        };
        this.onTabDragStart = async (dragListener, parentTab) => {
            this.isDragging = true;
            const onDragEnd = async (e, _, dimensions) => {
                var _a;
                this.isDragging = false;
                const { dropEffect } = e.originalEvent.dataTransfer;
                const isOutOfWindowDrop = dropEffect === 'none';
                const componentState = parentTab.contentItem.container.getState();
                const isAllowedDragOut = !(((_a = this.layout.config.settings) === null || _a === void 0 ? void 0 : _a.preventDragOut) || componentState.preventDragOut);
                if (isOutOfWindowDrop && isAllowedDragOut) {
                    this.handleOutOfWindowDrop(e, parentTab, dimensions);
                }
                await utils_1.delay(1);
                await this.showViews(true);
                dragListener.off('dragStop', onDragEnd);
            };
            dragListener.on('dragStop', onDragEnd);
            try {
                this.setBackgroundImages();
            }
            catch (e) {
                // want to let users know that they removed the div but not completely break
                console.error(e);
            }
            this.hideAllViews();
        };
        this.setBackgroundImage = async (viewComponent) => {
            if (!this.showBackgroundImages) {
                return;
            }
            const view = this.getOfViewFromComponentState(viewComponent.componentState);
            const options = {
                format: 'jpg',
                quality: 5
            };
            const img = await view.capturePage(options);
            if (!img.length) {
                return;
            }
            const containerDiv = viewComponent.container.getElement()[0];
            const openfinDiv = containerDiv.getElementsByClassName('openfin_default_background')[0];
            if (!openfinDiv) {
                throw new Error(`Div with class 'openfin_default_background' has been removed, replace this div or set showBackgroundImages: false on this window.`);
            }
            openfinDiv.innerHTML = `<div class="placeholder_image"><img src="data:image/png;base64, ${img}" /></div>`;
        };
        this.setBackgroundImages = async () => {
            if (!this.showBackgroundImages) {
                return;
            }
            const viewComponents = this.getViewComponents();
            const promises = viewComponents.map(async (vc) => {
                if (!vc.container.isHidden) {
                    await this.setBackgroundImage(vc);
                }
            });
            await Promise.all(promises);
        };
        this.addView = async (viewConfig) => {
            const existingComponent = this.getViewComponent(viewConfig);
            if (existingComponent) {
                return this.createAndAttachView(existingComponent);
            }
            const target = this.layout.root.contentItems[0];
            const newComponent = utils_1.createComponent(viewConfig);
            target.addChild(newComponent);
            const bv = this.getViewComponent(viewConfig);
            return this.createAndAttachView(bv);
        };
        this.removeView = async (viewConfig) => {
            try {
                const bv = this.getViewComponent(viewConfig);
                bv.container.tab.contentItem.remove();
            }
            catch (e) {
                // may have already been removed, this is OK
            }
            const view = this.getOfViewFromComponentState(viewConfig);
            await view.removeAllListeners();
            return view;
        };
        this.closeView = async (viewConfig) => {
            const bv = this.getViewComponent(viewConfig);
            if (!bv.componentState.isClosable) {
                throw new Error('Attemting to close a view with isClosable option set to false');
            }
            const ofView = await this.removeView(viewConfig);
            return view_pool_1.detachOrCloseView(ofView).catch(console.error);
        };
        this.createChannelConnections = async () => {
            this.client = await this.platform.getClient();
            this.client.register('add-view', this.addView);
            this.client.register('get-views', async () => {
                return this.getViewComponents().map((bv) => bv.componentState);
            });
            this.client.register('internal-remove-view', this.removeView);
            this.client.register('replace-layout', ({ layout, container }) => {
                const updateContainer = container || this.container;
                return this.replaceLayout(layout, updateContainer);
            });
            this.client.register('close-view', this.closeView);
            this.client.register('get-frame-snapshot', async () => {
                // Add the necessary view options for the snapshot
                const viewOptionsPromises = this.getViewComponents().map(async (viewComponent) => {
                    const { componentState } = viewComponent;
                    const ofView = this.getOfViewFromComponentState(componentState);
                    await utils_1.updateViewState(viewComponent, ofView);
                });
                await Promise.all(viewOptionsPromises);
                return this.layout.toConfig();
            });
            this.client.register('apply-preset-layout', (payload) => {
                const { presetType } = payload;
                const components = this.getViewComponents();
                const existingLayout = this.layout.toConfig();
                if (presetType === 'tabs' && !existingLayout.settings.hasHeaders) {
                    // tabs preset doesnt make sense without headers...
                    existingLayout.settings.hasHeaders = true;
                    existingLayout.dimensions.headerHeight = 20;
                }
                // existing layout might have a maximized view, need to reset
                existingLayout.maximisedItemId = null;
                const newLayout = {
                    ...existingLayout,
                    ...utils_1.generatePresetLayoutContent(components, presetType)
                };
                this.fin.Platform.Layout.getCurrentSync().replace(newLayout);
            });
        };
        this.getViewComponent = (identity) => {
            return this.getViewComponents().find((bv) => bv.componentState.name === identity.name);
        };
        this.getViewComponents = () => {
            return this.layout.root.getComponentsByName('view');
        };
        this.hideHighlight = () => {
            this.layout.dropTargetIndicator.hide();
        };
        this.getOfViewFromComponentState = (componentState) => {
            const { uuid } = this.ofWindow.identity;
            const { name } = componentState;
            const identity = { uuid, name };
            return this.fin.View.wrapSync(identity);
        };
        this.hideAllViews = () => {
            const views = this.getViewComponents();
            views.forEach((view) => {
                if (!view.container.isHidden) {
                    this.getOfViewFromComponentState(view.componentState).hide();
                }
            });
        };
        this.showViews = async (resize) => {
            const views = this.getViewComponents();
            let promiseMap;
            const viewShowPromises = views.map(this.updateViewVisibility);
            const updateViewBoundsPromises = views.map(async (viewState) => {
                const { container, componentState } = viewState;
                const element = container.getElement()[0];
                const rect = element.getBoundingClientRect();
                const ofView = this.getOfViewFromComponentState(componentState);
                return utils_1.setViewBoundsByRect(rect, ofView);
            });
            if (resize) {
                promiseMap = [...updateViewBoundsPromises, ...viewShowPromises];
            }
            else {
                promiseMap = viewShowPromises;
            }
            return Promise.all(promiseMap);
        };
        this.initializeLayoutViews = async () => {
            const viewComponents = this.getViewComponents();
            const viewLoadedPromises = [];
            const viewsResponsivePromises = [];
            // create ResizableViews, setup eventing and attach the views
            const resizableViewsCreated = viewComponents.map(async (viewComponent) => {
                const rView = await this.createResizableView(viewComponent);
                const viewLoadedPromise = utils_1.promisifyViewLoadEvents(rView.ofView, this.ofWindow.identity);
                viewLoadedPromises.push(viewLoadedPromise);
                const viewResponsivePromise = this.attachView(rView, viewComponent)
                    .then((ofView) => ({ success: true, identity: ofView.identity }))
                    .catch((e) => {
                    utils_1.handleRenderError(viewComponent, e);
                    return { success: false, identity: rView.ofView.identity, error: e };
                });
                viewsResponsivePromises.push(viewResponsivePromise);
            });
            // need to make sure we have all the promises in the arrays below
            await Promise.all(resizableViewsCreated);
            // these promises resolve when views are fully rendered.
            Promise.all(viewLoadedPromises).then((views) => this.dispatchLayoutEvent('layout-initialized', { views }));
            // promises resolve when views are responsive and all their events are set.
            Promise.all(viewsResponsivePromises).then((views) => this.dispatchLayoutEvent('layout-ready', { views }));
        };
        this.createResizableView = async (vc) => {
            const { container, componentState } = vc;
            try {
                // If the view is being reparented, it may not have the necessary/correct options in componentState
                const ofView = this.getOfViewFromComponentState(componentState);
                const options = await ofView.getOptions();
                const viewComponent = { ...vc, componentState: { ...options, ...componentState } };
                container.setState(viewComponent.componentState);
                return new resizable_view_1.ResizableView(this.fin, viewComponent, this.viewsResizeObserver);
            }
            catch (e) {
                // View does not yet exist, view will be created with the options in componentState
            }
            return new resizable_view_1.ResizableView(this.fin, vc, this.viewsResizeObserver);
        };
        this.attachView = async (rView, bv) => {
            this.setupViewEvents(rView.ofView, bv);
            utils_1.setFallbackBodyAndTitle(bv);
            try {
                await rView.renderIntoComponent();
                return rView.ofView;
            }
            catch (error) {
                utils_1.handleRenderError(bv, error);
                throw error;
            }
        };
        this.createAndAttachView = async (bv) => {
            const rView = await this.createResizableView(bv);
            return this.attachView(rView, bv);
        };
        this.setupViewEvents = (view, viewComponent) => {
            const logLoadError = (errName, e) => {
                // eslint-disable-next-line no-console
                console.error(`${errName} error occured while loading a view named ${view.identity.name}.\n error payload:`, e);
            };
            view.on('page-title-updated', ({ title }) => {
                utils_1.setTabTitle(viewComponent.container.tab, title);
            });
            // switch to the tab of the focused view when it's programmatically focused
            view.on('synth-focused', () => {
                const stack = viewComponent.container.tab.header.parent;
                const tabIndex = stack.contentItems.findIndex((cItem) => cItem.container.getState().name === viewComponent.componentState.name);
                try {
                    stack.setActiveContentItem(stack.contentItems[tabIndex]);
                }
                catch (e) {
                    console.log(`in view synth-focused. ${e.toString()}`);
                }
            });
            const onResourceLoadFailed = (e) => logLoadError('resource-load-failed', e);
            const onCrashed = (e) => logLoadError('crashed', e);
            const onDidFailLoad = (e) => logLoadError('did-fail-load', e);
            view.on('resource-load-failed', onResourceLoadFailed);
            view.on('crashed', onCrashed);
            view.on('did-fail-load', onDidFailLoad);
            // We might enter the resource fail load by mistake.
            view.on('did-finish-load', async () => {
                this.updateViewVisibility(viewComponent);
                const url = new URL(viewComponent.componentState.url);
                utils_1.setContainerMessage(viewComponent.container, url.hostname);
                this.setBackgroundImage(viewComponent);
            });
            // handle keyboard commands
            view.on('hotkey', (e) => commands_1.handleViewCommand(e, viewComponent, this));
            view.on('focused', () => {
                viewComponent.container.tab.element.addClass('focused_tab');
            });
            view.on('blurred', () => {
                viewComponent.container.tab.element.removeClass('focused_tab');
            });
            // if current window no longer owns the view, it shouldn't log it's errors
            view.on('target-changed', ({ target }) => {
                if (target.name !== this.ofWindow.identity.name || target.uuid !== this.ofWindow.identity.uuid) {
                    view.removeListener('resource-load-failed', onResourceLoadFailed);
                    view.removeListener('crashed', onCrashed);
                    view.removeListener('did-fail-load', onDidFailLoad);
                }
            });
        };
        this.dispatchLayoutEvent = async (action, payload = {}) => {
            const { uuid, name } = this.ofWindow.identity;
            const eventName = `window/${action}/${uuid}-${name}`;
            return this.ofWindow.wire.environment.raiseEvent(eventName, {
                ...payload,
                uuid,
                name,
                topic: 'window'
            });
        };
        this.ofWindow = this.fin.Window.getCurrentSync();
        this.platform = this.fin.Platform.getCurrentSync();
    }
}
exports.default = LayoutManager;
