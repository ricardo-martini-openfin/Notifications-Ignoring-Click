"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable class-methods-use-this, no-undef */
/* global localStorage */
const underscore_1 = require("underscore");
const utils_1 = require("./utils");
const EntityType_1 = require("../../../shapes/EntityType");
const commands_1 = require("./commands");
const errors_1 = require("../../../util/errors");
const Platform_1 = require("../../../shapes/Platform");
const view_pool_1 = require("./view-pool");
let hasInitialized = false;
function initConstructor(environment) {
    return async (userOverrideFn) => {
        if (hasInitialized) {
            throw new Error('Attempted to call Platform.init in an already running Platform. A Platform can only be initialized once.');
        }
        hasInitialized = true;
        const app = fin.Application.getCurrentSync();
        const { initialOptions: initialAppOptions } = await app.getInfo();
        const runRequestedLoopPreventionUrls = new Set();
        let provider;
        let platformProvider;
        let isReplacingSnapshot = false;
        if (!initialAppOptions.isPlatformController || fin.me.name !== fin.me.uuid) {
            // TODO: Link to relevant docs in error message
            throw new Error('fin.Platform.init should only be called from a custom platform provider running in the main window of the application.');
        }
        // ************* CONSTANTS / CONFIG **************
        const NON_APPLICABLE_OPTIONS = [
            'disableIabSecureLogging',
            'hideOnBlur',
            'hideOnClose',
            'hideWhileChildrenVisible',
            'isRawWindowOpen',
            'launchExternal',
            'loadErrorMessage',
            'plugins',
            'webSecurity',
            'show',
            'skipTaskbar',
            'enableLargerThanScreen',
            'enable-plugins',
            'webPreferences',
            'hasLoaded',
            'exitOnClose',
            'parent',
            'target'
        ];
        // Remove internal/non used values
        function sanitizeWinOptions(options) {
            return Object.fromEntries(Object.entries(options).filter(([key]) => !NON_APPLICABLE_OPTIONS.includes(key)));
        }
        const INTERNAL_DEFAULT_VIEW_OPTIONS = {
            bounds: {
                x: 1,
                y: 1,
                width: 0,
                height: 0
            },
            contextMenu: true,
            detachOnClose: false,
            isClosable: true,
            preventDragOut: false
        };
        const MANDATORY_VIEW_OPTIONS = {
            backgroundThrottling: true,
            autoResize: {
                width: false,
                height: false
            }
        };
        const INTERNAL_DEFAULT_WINDOW_OPTIONS = {
            frame: false,
            defaultWidth: 800,
            defaultHeight: 800,
            minWidth: 200,
            minHeight: 200,
            resizeRegion: {
                bottomRightCorner: 20
            },
            backgroundThrottling: true,
            contextMenuSettings: {
                enable: false,
                devtools: true,
                reload: false
            },
            showBackgroundImages: false,
            // Injection code use this url to know when to inject default frame
            url: 'about:blank?of-internal-inject-platform-frame'
        };
        // note: make sure to update the docs if you change the mandatory window/view options.
        const MANDATORY_PLATFORM_WINDOW_OPTIONS = {};
        const MANDATORY_WINDOW_OPTIONS = {
            saveWindowState: false
        };
        const INTERNAL_DEFAULT_SETTINGS_OPTIONS = {
            hasHeaders: true,
            reorderEnabled: true,
            showPopoutIcon: false,
            showCloseIcon: false,
            showMaximiseIcon: false,
            popoutWholeStack: false,
            constrainDragToHeaders: false,
            preventDragOut: false,
            preventDragIn: false
        };
        const INTERNAL_DEFAULT_DIMENSIONS = {
            borderWidth: 5,
            minItemHeight: 10,
            minItemWidth: 10,
            headerHeight: 25
        };
        const MANDATORY_SETTINGS_OPTIONS = {
            blockedPopoutsThrowError: true,
            closePopoutsOnUnload: true,
            constrainDragToContainer: true,
            selectionEnabled: false // not sure about this one
        };
        const INTERNAL_MAX_POOLED_VIEWS = 10;
        const dispatchPlatformEvent = async (action, payload = {}) => {
            const { identity: { uuid } } = fin.me;
            const eventName = `application/${action}/${uuid}`;
            return environment.raiseEvent(eventName, {
                ...payload,
                uuid,
                topic: 'application'
            });
        };
        const raiseHostContextChanged = async (target, payload) => {
            const { uuid, name } = target;
            const eventName = `view/host-context-changed/${uuid}-${name}`;
            return environment.raiseEvent(eventName, {
                ...payload,
                uuid,
                name,
                topic: 'view'
            });
        };
        const CHILD_WINDOW_NAME_PREFIX = 'internal-generated-window-';
        const VIEW_NAME_PREFIX = 'internal-generated-view-';
        const STANDARD_FRAME_PATH = 'standard-frame';
        const uniqueMergeValidArraysInOrder = (arr1, arr2) => [
            ...new Set([...(Array.isArray(arr1) ? arr1 : []), ...(Array.isArray(arr2) ? arr2 : [])])
        ];
        async function convertWindowOptions(givenOptions) {
            // Option inheritance with a few non overridable properties and name if not given.
            const name = CHILD_WINDOW_NAME_PREFIX + fin.desktop.getUuid();
            const defaultWindowOptions = initialAppOptions.defaultWindowOptions || {};
            const preloadScripts = uniqueMergeValidArraysInOrder(defaultWindowOptions.preloadScripts, givenOptions.preloadScripts);
            givenOptions.hotkeys = commands_1.setUpKeyboardCommands(defaultWindowOptions.hotkeys, givenOptions.hotkeys, initialAppOptions);
            if (givenOptions.layout) {
                return {
                    name,
                    ...INTERNAL_DEFAULT_WINDOW_OPTIONS,
                    ...defaultWindowOptions,
                    ...givenOptions,
                    preloadScripts,
                    ...MANDATORY_WINDOW_OPTIONS,
                    ...MANDATORY_PLATFORM_WINDOW_OPTIONS,
                    layout: await convertLayoutOptions(givenOptions.layout)
                };
            }
            return {
                name,
                ...defaultWindowOptions,
                ...givenOptions,
                preloadScripts,
                ...MANDATORY_WINDOW_OPTIONS // make sure to update the docs if you change the mandatory options.
            };
        }
        async function convertLayoutOptions(initialLayout) {
            const modifiedLayout = { ...initialLayout };
            // NOTE: Setting mimimum dimensions for itemwidth and itemheight can result in golden-layout drag area bugs
            modifiedLayout.settings = {
                ...INTERNAL_DEFAULT_SETTINGS_OPTIONS,
                ...initialLayout.settings,
                ...MANDATORY_SETTINGS_OPTIONS
            };
            modifiedLayout.dimensions = {
                ...INTERNAL_DEFAULT_DIMENSIONS,
                ...initialLayout.dimensions
            };
            modifiedLayout.content = await mapLayoutContentItems(initialLayout.content, convertComponentState);
            return modifiedLayout;
        }
        async function convertComponentState(viewComponent) {
            const newViewComponentState = await convertViewOptions(viewComponent.componentState);
            return {
                ...viewComponent,
                componentState: newViewComponentState
            };
        }
        function modifyContentItemName(contentItem, shouldReplace) {
            const name = generateViewNameIfNeeded(contentItem.componentState.name, shouldReplace);
            const newComponentState = { ...contentItem.componentState, name };
            return { ...contentItem, componentState: newComponentState };
        }
        function generateViewNameIfNeeded(name, shouldReplace) {
            // either the view has no name OR it is being restored and has a generated name
            return !name || (shouldReplace && name.startsWith(VIEW_NAME_PREFIX))
                ? VIEW_NAME_PREFIX + fin.desktop.getUuid()
                : name;
        }
        function mapLayoutContentItems(contentItems, action) {
            return contentItems.reduce(async (res, contentItem) => {
                let modifiedContentItemContent = contentItem.content;
                const modifiedContentItem = contentItem.type === 'component' ? await action(contentItem) : contentItem;
                if (contentItem.content) {
                    modifiedContentItemContent = await mapLayoutContentItems(contentItem.content, action);
                }
                return [...(await res), { ...modifiedContentItem, content: modifiedContentItemContent }];
            }, Promise.resolve([]));
        }
        async function convertViewOptions(opts = {}) {
            const { manifestUrl } = opts;
            if (manifestUrl) {
                const manifestOptions = await platformProvider.fetchManifest({ manifestUrl }, fin.me.identity);
                // eslint-disable-next-line no-param-reassign
                opts = { ...opts, ...manifestOptions, manifestUrl };
            }
            const defaultViewOptions = initialAppOptions.defaultViewOptions || {};
            const preloadScripts = uniqueMergeValidArraysInOrder(defaultViewOptions.preloadScripts, opts.preloadScripts);
            const hotkeys = commands_1.setUpKeyboardCommands(defaultViewOptions.hotkeys, opts.hotkeys, initialAppOptions);
            return {
                ...INTERNAL_DEFAULT_VIEW_OPTIONS,
                ...defaultViewOptions,
                ...opts,
                preloadScripts,
                hotkeys,
                ...MANDATORY_VIEW_OPTIONS
            };
        }
        const convertSnapshotWindowOptions = async (snapshot) => {
            const modifiedWindowConfigs = await Promise.all(snapshot.windows.map(convertWindowOptions));
            return { ...snapshot, windows: modifiedWindowConfigs };
        };
        // ************* UTILS **************
        const windowExists = async (winName) => {
            const application = fin.Application.getCurrentSync();
            const childWindows = await application.getChildWindows();
            return childWindows.some((win) => win.identity.name === winName);
        };
        // MAKE ME REAL OR KILL ME
        // const getAllViews = async () => {
        //     // LATER TO BE REPLACED WITH CALL FROM CORE (WITH SAME PROPERTIES)...???
        //     const wrappedChildWins = await fin.Application.getCurrentSync().getChildWindows();
        //     const promiseArr = wrappedChildWins.map(async (w) => await w.getCurrentViews());
        //     const flattenedViews = await Promise.all(promiseArr).then(arr => arr.reduce((acc, elem, idx) => {
        //         // add target window to info
        //         const target = wrappedChildWins[idx].identity;
        //         const bvInfoArr = elem.map(b => {
        //             b.target = target;
        //             return b;
        //         });
        //         return [...acc, ...bvInfoArr];
        //     }, []));
        //     return Promise.all(flattenedViews.map(async (v) => {
        //         const info = await v.getInfo();
        //         info.target = v.target;
        //         return info;
        //     }));
        // };
        // const getAllWindows = async () => {
        //     const uuid = fin.Application.getCurrentSync().identity.uuid;
        //     const { mainWindow, childWindows } = await fin.System.getAllWindows().then(wins => wins.find(win => win.uuid === uuid));
        //     const decoratedController = { ...mainWindow, uuid, isController: true };
        //     const decoratedChildren = childWindows.map(w => {
        //         return { ...w, isController: false, uuid };
        //     });
        //     return [decoratedController, ...decoratedChildren];
        // };
        // const closeWindow = identity => fin.Window.wrapSync(identity).close();
        const resolveWhenLayoutReady = (win) => new Promise((res) => win.on('layout-ready', () => res()));
        async function openSnapshot(snapshot) {
            const currentWindowNames = (await fin.Application.getCurrentSync().getChildWindows()).map((win) => win.identity.name);
            const creationPromises = snapshot.windows.map(async (windowOptions) => {
                const { uuid } = fin.me;
                const win = fin.Window.wrapSync({ uuid, name: windowOptions.name });
                const resolveCondition = windowOptions.layout ? resolveWhenLayoutReady(win) : undefined;
                if (currentWindowNames.includes(windowOptions.name)) {
                    if (windowOptions.layout) {
                        await platformProvider.replaceLayout({ opts: windowOptions, target: win.identity }, fin.me.identity);
                    }
                    platformProvider.setWindowContext({
                        target: win.identity,
                        entityType: EntityType_1.default.WINDOW,
                        context: windowOptions.customContext
                    }, fin.me.identity);
                    if (windowOptions.state === 'minimized') {
                        win.minimize();
                    }
                    else if (windowOptions.state === 'maximized') {
                        win.maximize();
                    }
                    const x = windowOptions.x || windowOptions.defaultLeft;
                    const y = windowOptions.y || windowOptions.defaultTop;
                    const width = windowOptions.width || windowOptions.defaultWidth;
                    const height = windowOptions.height || windowOptions.defaultHeight;
                    if (width && height) {
                        win.resizeTo(width, height, 'top-left');
                    }
                    if (x && y) {
                        win.moveTo(x, y);
                    }
                    return resolveCondition;
                }
                const pooledViewMap = await view_pool_1.getPooledViewObject();
                if (windowOptions.layout) {
                    windowOptions.layout.content = (await mapLayoutContentItems(windowOptions.layout.content, async (contentItem) => modifyContentItemName(contentItem, !pooledViewMap[contentItem.componentState.name])));
                }
                await platformProvider.createWindow(windowOptions, fin.me.identity);
                return resolveCondition;
            });
            await Promise.all(creationPromises);
            dispatchPlatformEvent('platform-snapshot-applied', { snapshot });
        }
        // TODO: non-any types would be better
        const launchIntoPlatform = async ({ manifest, userAppConfigArgs = {} }) => {
            const { launchManifestIntoPlatform, appManifestUrl } = userAppConfigArgs;
            // launchManifestIntoPlatform in userAppConfigArgs means there is a separate manifest to launch than the target manifest,
            // either from a fins link or launchContentManifest API call, this one should be launched instead
            if (launchManifestIntoPlatform &&
                (launchManifestIntoPlatform.startup_app || launchManifestIntoPlatform.snapshot)) {
                try {
                    runRequestedLoopPreventionUrls.delete(appManifestUrl);
                    const { startup_app, snapshot } = launchManifestIntoPlatform;
                    // if there is a snapshot in that manifest, it takes precedence launch the snapshot and ignore the initial manifest
                    if (snapshot) {
                        return platformProvider.applySnapshot({ snapshot: await convertSnapshotWindowOptions(snapshot) }, fin.me.identity);
                    }
                    // if there is not a snapshot it is a legacy manifest, try to launch the main window described
                    // in startup_app as a single view in a new window
                    // TODO - we need a way to allow users to put this single view into a location in an existing window
                    startup_app.name = startup_app.uuid;
                    const layout = {
                        content: [
                            {
                                type: 'stack',
                                content: [
                                    {
                                        type: 'component',
                                        componentName: 'view',
                                        componentState: startup_app
                                    }
                                ]
                            }
                        ]
                    };
                    const windowOptions = {
                        ...(await convertWindowOptions({ layout })),
                        reason: Platform_1.WindowCreationReason.AppCreation
                    };
                    return platformProvider.createWindow(windowOptions, fin.me.identity);
                }
                catch (err) {
                    // there was a second manifest to launch but there were issues launching it, throw error
                    throw new Error(`Error launching manifest into platform: ${JSON.stringify(launchManifestIntoPlatform)}
                        ${JSON.stringify(errors_1.errorToPOJO(err))}`);
                }
            }
            // this logic may not be necessary, but essentially if there is an appManifestUrl, then the core SHOULD have added
            // a launchManifestIntoPlatform property or thrown an error.  There may be some multi-runtime instances where this is not true
            // if that is the case, this will take one more trip to the core and go through the correct logic.
            if (appManifestUrl) {
                if (runRequestedLoopPreventionUrls.has(appManifestUrl)) {
                    runRequestedLoopPreventionUrls.delete(appManifestUrl);
                    throw new Error(`Unable to fetch manifest at url ${appManifestUrl}`);
                }
                // if this fails to fetch in the core, it gets sent back
                // this is in order to ensure that the first manifest fetch works successfully if it needs auth
                runRequestedLoopPreventionUrls.add(appManifestUrl);
                return fin.Platform.getCurrentSync().launchContentManifest(appManifestUrl);
            }
            // there was no second target manifest, this is a normal run-requested event
            const snapshot = manifest === null || manifest === void 0 ? void 0 : manifest.snapshot;
            if (snapshot) {
                // check the original manifest for a snapshot and launch it
                return platformProvider.applySnapshot({ snapshot: await convertSnapshotWindowOptions(snapshot) }, fin.me.identity);
            }
            throw new Error('Failed to launch into platform, no snapshot included in manifest.');
        };
        // Startup setup needed ASAP
        const startupRunRequestedPromise = app.on('run-requested', launchIntoPlatform);
        const startupWindowClosePromise = app.on('window-closed', async () => {
            if (!isReplacingSnapshot) {
                const childWindows = await app.getChildWindows();
                const isShowing = await fin.me.isShowing();
                if (childWindows.length < 1 && !isShowing) {
                    localStorage.removeItem('user-snapshot');
                    platformProvider.quit(undefined, fin.me.identity);
                }
            }
        });
        const maxViewPoolSize = typeof initialAppOptions.maxViewPoolSize === 'number'
            ? initialAppOptions.maxViewPoolSize
            : INTERNAL_MAX_POOLED_VIEWS;
        view_pool_1.setupViewPool(maxViewPoolSize);
        return new Promise((resolve, reject) => {
            // ************* INIT **************
            fin.desktop.main(async (userAppConfigArgs = {}) => {
                try {
                    const { appManifestUrl } = userAppConfigArgs;
                    // Create channel & setup API
                    const channelName = `custom-frame-${app.identity.uuid}`;
                    provider = await fin.InterApplicationBus.Channel.create(channelName);
                    // If the provider has not defined an action, we forward it to a given target.
                    provider.setDefaultAction(async (action, { target, opts }, identity) => {
                        const client = provider.connections.find((c) => c.name === target.name);
                        if (client) {
                            return provider.dispatch(client, action, opts);
                        }
                        throw new Error(`Client with name ${target.name} not found`);
                    });
                    /**
                     * @classdesc This class handles Platform actions. It does not need to be used directly by developers.
                     * However, its methods can be overriden by passing an `overrideCallback` to {@link Platform#init Platform.init}
                     * in order to implement custom Platform behavior. (See {@tutorial Platform.init})
                     *
                     * For an overview of Provider customization, see
                     * {@link https://developers.openfin.co/docs/platform-customization#section-customizing-platform-behavior}.
                     * @class
                     * @alias PlatformProvider
                     * @hideconstructor
                     */
                    class DefaultProvider {
                        /**
                         * Handles requests to create a window in the current platform.
                         * @param { WindowOption } payload Window options for the window to be created.
                         * @param { Identity } callerIdentity If {@link Platform#createWindow Platform.createWindow}
                         * was called, the identity of the caller will be here.
                         * If `createWindow` was called as part of applying a snapshot or
                         * creating a view without a target window, `callerIdentity` will be the provider's identity.
                         * @tutorial PlatformProvider.createWindow
                         */
                        async createWindow(options, callerIdentity) {
                            const { reason = Platform_1.WindowCreationReason.APICall, ...windowOptions } = options;
                            const pooledViewMap = await view_pool_1.getPooledViewObject();
                            if (windowOptions.layout) {
                                windowOptions.layout.content = await mapLayoutContentItems(windowOptions.layout.content, async (contentItem) => modifyContentItemName(contentItem, !pooledViewMap[contentItem.componentState.name] &&
                                    reason !== Platform_1.WindowCreationReason.Tearout &&
                                    // In the CreateViewWithoutTarget case, we have already generated a name for the view.
                                    // Generating a new one will mess up listeners created as part of view creation.
                                    reason !== Platform_1.WindowCreationReason.CreateViewWithoutTarget));
                            }
                            return fin.Window.create(await convertWindowOptions(windowOptions));
                        }
                        /**
                         * Handles requests to fetch manifests in the current platform.
                         * @param { FetchManifestPayload } payload Payload containing the manifestUrl to be fetched.
                         * @param { Identity } callerIdentity If {@link Platform#fetchManifest Platform.fetchManifest}
                         * was called, the identity of the caller will be here.
                         * If `fetchManifest` was called internally, `callerIdentity` will be the provider's identity.
                         * @tutorial PlatformProvider.fetchManifest
                         */
                        async fetchManifest(payload, callerIdentity) {
                            const { manifestUrl } = payload;
                            return fin.System.fetchManifest(manifestUrl);
                        }
                        /**
                         * Gets the current state of windows and their views and returns a snapshot object containing that info.
                         * @param { undefined } payload Undefined unless you've defined a custom `getSnapshot` protocol.
                         * @param { Identity } callerIdentity Identity of the entity that called
                         * {@link Platform#getSnapshot Platform.getSnapshot}.
                         * @return { Promise<Snapshot> } Snapshot of current platform state.
                         * @tutorial PlatformProvider.getSnapshot
                         */
                        async getSnapshot(payload, callerIdentity) {
                            // NOTE: may need main window if not headless
                            const application = fin.Application.getCurrentSync();
                            const allWindows = await application.getChildWindows();
                            const windowsPromises = allWindows.map(async (win) => {
                                const windowOptionsPromise = win.getOptions().then((options) => {
                                    if (options.name && options.name.startsWith(CHILD_WINDOW_NAME_PREFIX)) {
                                        // window was not initially given a name, represents a view container
                                        options.name = undefined;
                                    }
                                    if (options.url && options.url.includes(STANDARD_FRAME_PATH)) {
                                        // remove url to default to openfin or platform default view container URL
                                        options.url = undefined;
                                    }
                                    return sanitizeWinOptions(options);
                                });
                                // // get current bounds and state ////
                                // todo: fix getOptions to get the right options for these too.
                                const windowBoundsPromise = win.getBounds().then(({ height, left, top, width }) => ({
                                    // map bounds to win options
                                    defaultHeight: height,
                                    defaultWidth: width,
                                    defaultLeft: left,
                                    defaultTop: top
                                }));
                                const windowStatePromise = win.getState();
                                const windowInfoPromise = win.getInfo();
                                // using this try catch here to return a snapshot for windows that don't have a layouts property
                                // if a window is not part of a Platform it can't find a client and the promise will fail
                                // yes, this is hacky
                                try {
                                    // get the layout from the window
                                    const client = provider.connections.find((c) => c.name === win.identity.name);
                                    const layoutPromise = provider.dispatch(client, 'get-frame-snapshot');
                                    const [bounds, state, winOptions, layout, { url, title }] = await Promise.all([
                                        windowBoundsPromise,
                                        windowStatePromise,
                                        windowOptionsPromise,
                                        layoutPromise,
                                        windowInfoPromise
                                    ]);
                                    return {
                                        ...winOptions,
                                        ...bounds,
                                        state,
                                        ...MANDATORY_WINDOW_OPTIONS,
                                        ...MANDATORY_PLATFORM_WINDOW_OPTIONS,
                                        layout,
                                        url,
                                        title
                                    };
                                }
                                catch (e) {
                                    // return regular window options if failed to get a layout
                                    return Promise.all([
                                        windowBoundsPromise,
                                        windowStatePromise,
                                        windowOptionsPromise,
                                        windowInfoPromise
                                    ]).then(([bounds, state, winOptions, { url, title }]) => ({
                                        ...winOptions,
                                        ...bounds,
                                        state,
                                        ...MANDATORY_WINDOW_OPTIONS,
                                        url,
                                        title
                                    }));
                                }
                            });
                            const runtimeVersionPromise = application.getInfo().then(({ runtime }) => runtime.version);
                            const monitorInfoPromise = fin.System.getMonitorInfo();
                            // the double promise wrapping is to make sure all calls happen concurrently
                            const windowsPromise = Promise.all(windowsPromises);
                            return Promise.all([runtimeVersionPromise, windowsPromise, monitorInfoPromise]).then(([runtimeVersion, windows, monitorInfo]) => ({
                                snapshotDetails: {
                                    timestamp: new Date().toISOString(),
                                    runtimeVersion,
                                    monitorInfo
                                },
                                windows
                            }));
                        }
                        /**
                         * Called when a snapshot is being applied and some windows in that snapshot would be fully or partially off-screen.
                         * Returns an array of windows with modified positions,such that any off-screen windows are positioned
                         * in the top left corner of the main monitor.
                         * @param { Snapshot } snapshot The snapshot to be applied.
                         * @param { WindowOptions[] } outOfBoundsWindows An array of WindowOptions for any windows that would be off-screen.
                         * @return { Promise<WindowOptions[]> } An array of WindowOptions with their position modified to fit on screen.
                         * @tutorial PlatformProvider.positionOutOfBoundsWindows
                         */
                        async positionOutOfBoundsWindows(snapshot, outOfBoundsWindows) {
                            const finalWindows = [...snapshot.windows];
                            // Offset each window's adjusted position so that each title bar is visible
                            const OFFSET = 20;
                            const { primaryMonitor: { availableRect: { left, top, right, bottom } } } = await fin.System.getMonitorInfo();
                            outOfBoundsWindows.forEach((windowOptions, i) => {
                                const index = finalWindows.indexOf(windowOptions);
                                // Cascade windows from top left of primary monitor
                                const defaultLeft = left + ((OFFSET * i) % (OFFSET * 10));
                                const defaultTop = top + ((OFFSET * i) % (OFFSET * 10));
                                const newWinOptions = { ...windowOptions, defaultLeft, defaultTop };
                                // Resize windows to fit on screen, in case new monitor is smaller
                                if (defaultLeft + newWinOptions.defaultWidth > right) {
                                    newWinOptions.defaultWidth = right - defaultLeft;
                                }
                                if (defaultTop + newWinOptions.defaultHeight > bottom) {
                                    newWinOptions.defaultHeight = bottom - defaultTop;
                                }
                                // Put modified windows at end of array,
                                // so they will be in foreground
                                finalWindows.splice(index, 1);
                                finalWindows.push(newWinOptions);
                            });
                            return finalWindows;
                        }
                        /**
                         * Handles requests to apply a snapshot to the current Platform.
                         * @param { ApplySnapshotPayload } payload Payload containing the snapshot to be applied, as well as any options.
                         * @param { Identity } callerIdentity Identity of the entity that called
                         * {@link Platform#applySnapshot Platform.applySnapshot}.
                         * If called internally (e.g. when opening the initial snapshot),
                         * `callerIdentity` will be the identity of the provider.
                         * @return { Promise<void> }
                         * @tutorial PlatformProvider.applySnapshot
                         */
                        async applySnapshot(payload, callerIdentity) {
                            var _a;
                            const { snapshot, options } = payload;
                            if (options === null || options === void 0 ? void 0 : options.closeExistingWindows) {
                                isReplacingSnapshot = true;
                                // kill all current windows.
                                const allCurrentWindows = await fin.Application.getCurrentSync().getChildWindows();
                                const winClosePromises = allCurrentWindows.map((win) => win.close(true).catch(() => null));
                                await Promise.all(winClosePromises);
                            }
                            const finalSnapshot = await convertSnapshotWindowOptions(snapshot);
                            if (!(options === null || options === void 0 ? void 0 : options.skipOutOfBoundsCheck) && ((_a = snapshot === null || snapshot === void 0 ? void 0 : snapshot.snapshotDetails) === null || _a === void 0 ? void 0 : _a.monitorInfo)) {
                                const monitorInfo = await fin.System.getMonitorInfo();
                                if (!underscore_1.isEqual(monitorInfo, snapshot.snapshotDetails.monitorInfo)) {
                                    const outOfBoundsWindows = await utils_1.getOutOfBoundsWindows(finalSnapshot, monitorInfo);
                                    if (outOfBoundsWindows.length) {
                                        const finalWindows = await platformProvider.positionOutOfBoundsWindows(finalSnapshot, outOfBoundsWindows);
                                        finalSnapshot.windows = finalWindows;
                                    }
                                }
                            }
                            await openSnapshot(finalSnapshot);
                            isReplacingSnapshot = false;
                        }
                        /**
                         * Closes the current Platform and all child windows and views.
                         * @param { undefined } payload Undefined unless you have implemented a custom quite protocol.
                         * @param { Identity } callerIdentity Identity of the entity that called {@link Platform#quit Platform.quit}.
                         * If called in response to the last window in a platform closing, `callerIdentity` will be the provider's identity.
                         * @return { Promise<void> }
                         * @tutorial PlatformProvider.quit
                         */
                        quit(payload, callerIdentity) {
                            // const willSave = confirm('Do you want to save a snapshot of this layout to restore on next launch?');
                            // if (willSave) {
                            //     const snapshot = await getSnapshot(provider);
                            //     localStorage.setItem('user-snapshot', JSON.stringify(snapshot));
                            // } else {
                            //     localStorage.removeItem('user-snapshot');
                            // }
                            return fin.Application.getCurrentSync().quit();
                        }
                        /**
                         * Closes a view
                         * @param { CloseViewPayload } payload Specifies the `target` view to be closed.
                         * @param { Identity } callerIdentity Identity of the entity that called
                         * {@link Platform#closeView Platform.closeView}.
                         * @tutorial PlatformProvider.closeView
                         */
                        async closeView(payload, callerIdentity) {
                            const { view: viewIdentity } = payload;
                            const view = await fin.View.wrap(viewIdentity);
                            const { identity: windowIdentity } = await view.getCurrentWindow();
                            if (windowIdentity.name === windowIdentity.uuid) {
                                // view is attached to the provider as part of the view pool, close it here
                                // do we need to implement "force" behavior here? or just let people use API overwrite?
                                return fin.View.wrapSync(viewIdentity).destroy();
                            }
                            return provider.dispatch(windowIdentity, 'close-view', viewIdentity);
                        }
                        /**
                         * Creates a new view and attaches it to a specified target window.
                         * @param { CreateViewPayload } payload Creation options for the new view.
                         * @param { Identity } callerIdentity Identity of the entity that called
                         * {@link Platform#createView Platform.createView}.
                         * @return { Promise<void> }
                         */
                        async createView(payload, callerIdentity) {
                            const { opts, target } = payload;
                            opts.name = generateViewNameIfNeeded(opts.name, false);
                            const { uuid } = fin.me.identity;
                            if (target) {
                                // will move from another layout window if already exists
                                // will create or attach the BV but we should document just create
                                const viewOptions = await convertViewOptions(opts);
                                if (target.name === fin.me.name) {
                                    return fin.View.create({ ...viewOptions, target }).then((view) => {
                                        // With the flag views have loaded the initial url
                                        if (!fin.__internal_.childViews) {
                                            view.navigate(viewOptions.url);
                                        }
                                        return view;
                                    });
                                }
                                return provider.dispatch(target, 'add-view', viewOptions);
                            }
                            const layout = utils_1.generateLayoutContent(opts);
                            const options = {
                                uuid,
                                layout,
                                reason: Platform_1.WindowCreationReason.CreateViewWithoutTarget
                            };
                            return new Promise((res) => {
                                const view = fin.View.wrapSync({ uuid, name: opts.name });
                                // View could already exist, target-changed fires on creation so will capture either case
                                view.once('target-changed', () => res(view));
                                this.createWindow(options, fin.me.identity);
                            });
                        }
                        /**
                         * Replaces a Platform window's layout with a new layout. Any views that were in the
                         * old layout but not the new layout will be destroyed.
                         * @param { ReplaceLayoutPayload } payload Contains the `target` window and
                         * an `opts` object with a `layout` property to apply.
                         * @param { Identity } callerIdentity Identity of the entity that called
                         * {@link Platform#replaceLayout Platform.replaceLayout}.
                         * If `replaceLayout` is called internally (e.g. while applying a snapshot),
                         * `callerIdentity` will be the provider's identity.
                         * @return { Promise<void> }
                         * @tutorial PlatformProvider.replaceLayout
                         */
                        async replaceLayout(payload, callerIdentity) {
                            const { opts, target } = payload;
                            const modifiedLayout = await convertLayoutOptions(opts.layout);
                            const newOptions = { ...opts, layout: modifiedLayout };
                            // we only want to generate a random name if: (1) the view has no name (2) the view has a generated name
                            // AND (3) doesn't exist in the current window or in the view pool
                            const windowViews = await fin.Window.wrapSync(target).getCurrentViews();
                            const pooledViews = await fin.Window.getCurrentSync().getCurrentViews();
                            const viewNamesMap = [...windowViews, ...pooledViews].reduce((carry, view) => ({ ...carry, [view.identity.name]: true }), {});
                            const modifiedRootContentItem = await mapLayoutContentItems(newOptions.layout.content, async (contentItem) => modifyContentItemName(contentItem, !viewNamesMap[contentItem.componentState.name]));
                            newOptions.layout.content = modifiedRootContentItem;
                            return provider.dispatch(target, 'replace-layout', newOptions);
                        }
                        /**
                         * Handles requests to set a window's context. `target` may be a window or a view.
                         * If it is a window, that window's `customContext` will be updated.
                         * If it is a view, the `customContext` of that view's current host window will be updated.
                         * @param { SetWindowContextPayload } payload Object containing the requested `context` update,
                         * the `target`'s identity, and the target's `entityType`.
                         * @param { Identity } callerIdentity Identity of the entity that called
                         * {@link Platform#setWindowContext Platform.setWindowContext}.
                         * If `setWindowContext` is called internally (e.g. while applying a snapshot),
                         * `callerIdentity` will be the provider's identity.
                         * @return { Promise<any> } The new context.
                         * @tutorial PlatformProvider.setWindowContext
                         */
                        async setWindowContext(payload, callerIdentity) {
                            const { context, entityType, target } = payload;
                            let targetWindow;
                            if (entityType === 'window') {
                                targetWindow = fin.Window.wrapSync(target);
                            }
                            else if (entityType === 'view') {
                                targetWindow = await fin.View.wrapSync(target).getCurrentWindow();
                            }
                            else {
                                throw new Error(`Unknown entity type: "${entityType}". This call can only be made from a Window or a View.`);
                            }
                            const optionsUpdate = { customContext: context };
                            await targetWindow.updateOptions(optionsUpdate);
                            const { uuid, name } = targetWindow.identity;
                            await environment.raiseEvent(`window/context-changed/${uuid}-${name}`, {
                                context,
                                uuid,
                                name,
                                topic: 'window'
                            });
                            return context;
                        }
                        /**
                         * Handles requests to get a window's context. `target` may be a window or a view.
                         * If it is a window, that window's `customContext` will be returned.
                         * If it is a view, the `customContext` of that view's current host window will be returned.
                         * @param { GetWindowContextPayload } payload Object containing the requested `context` update,
                         * the `target`'s identity, and the target's `entityType`.
                         * @param { Identity } callerIdentity Identity of the entity that called
                         * {@link Platform#getWindowContext Platform.getWindowContext}.
                         * If `getWindowContext` is called internally (e.g. when getting a window's context for the purpose of raising a
                         * "host-context-changed" event on a reparented view), callerIdentity will be the provider's identity.
                         * @return { Promise<any> } The new context.
                         * @tutorial PlatformProvider.getWindowContext
                         */
                        async getWindowContext(payload, callerIdentity) {
                            const { target, entityType } = payload;
                            let targetWindow;
                            if (entityType === 'window') {
                                targetWindow = fin.Window.wrapSync(target);
                            }
                            else if (entityType === 'view') {
                                targetWindow = await fin.View.wrapSync(target).getCurrentWindow();
                            }
                            else {
                                throw new Error(`Unknown entity type: "${entityType}". This call can only be made from a Window or a View.`);
                            }
                            const { customContext } = await targetWindow.getOptions();
                            return customContext;
                        }
                        /**
                         * Called when a window's `customContext` is updated.
                         * Responsible for raising the `host-context-updated` event on that window's child views.
                         * @param { WindowOptionsChangedEvent<'window', 'options-changed'> } payload The event payload for the window
                         * whose context has changed.
                         * The new context will be contained as `payload.diff.customContext.newVal`.
                         * @return { Promise<HostContextChangedPayload> } The event that it raised.
                         */
                        async onWindowContextUpdated(payload) {
                            var _a;
                            const { uuid, name, diff } = payload;
                            if ((_a = diff === null || diff === void 0 ? void 0 : diff.customContext) === null || _a === void 0 ? void 0 : _a.newVal) {
                                const { newVal: context } = diff.customContext;
                                const views = await fin.Window.wrapSync({ uuid, name }).getCurrentViews();
                                const eventPayload = {
                                    context,
                                    reason: Platform_1.HostContextChangedReasons.updated
                                };
                                views.forEach(({ identity: viewIdentity }) => {
                                    raiseHostContextChanged(viewIdentity, eventPayload);
                                });
                                return eventPayload;
                            }
                            return undefined;
                        }
                    }
                    platformProvider = new DefaultProvider();
                    if (userOverrideFn) {
                        try {
                            // TODO: better validation
                            platformProvider = await userOverrideFn(DefaultProvider);
                        }
                        catch (err) {
                            throw new Error(`Error applying custom platform provider: ${err}`);
                        }
                    }
                    provider.register('set-window-context', platformProvider.setWindowContext.bind(platformProvider));
                    provider.register('get-window-context', platformProvider.getWindowContext.bind(platformProvider));
                    provider.register('create-view-container', platformProvider.createWindow.bind(platformProvider));
                    provider.register('platform-fetch-manifest', platformProvider.fetchManifest.bind(platformProvider));
                    provider.register('get-snapshot', platformProvider.getSnapshot.bind(platformProvider));
                    provider.register('apply-snapshot', platformProvider.applySnapshot.bind(platformProvider));
                    provider.register('quit', platformProvider.quit.bind(platformProvider));
                    provider.register('close-view', platformProvider.closeView.bind(platformProvider));
                    provider.register('create-view', platformProvider.createView.bind(platformProvider));
                    provider.register('replace-layout', platformProvider.replaceLayout.bind(platformProvider));
                    Object.keys(platformProvider).forEach((key) => {
                        provider.register(key, platformProvider[key].bind(platformProvider));
                    });
                    provider.onError((action, error, identity) => {
                        // eslint-disable-next-line no-console
                        console.error(`Error on action ${action} sent by ${JSON.stringify(identity)}: ${JSON.stringify(errors_1.errorToPOJO(error))}`);
                        throw error;
                    });
                    app.on('window-created', ({ uuid, name }) => {
                        const ofWin = fin.Window.wrapSync({ uuid, name });
                        const optionsChangedListener = platformProvider.onWindowContextUpdated.bind(platformProvider);
                        ofWin.on('options-changed', optionsChangedListener);
                        ofWin.on('closed', () => ofWin.removeListener('options-changed', optionsChangedListener));
                    });
                    app.on('view-created', (identity) => {
                        const view = fin.View.wrapSync(identity);
                        const reparentHandler = async () => {
                            const context = await fin.Platform.getCurrentSync().getWindowContext(identity);
                            raiseHostContextChanged(identity, {
                                context,
                                reason: Platform_1.HostContextChangedReasons.reparented
                            });
                        };
                        view.on('target-changed', reparentHandler);
                        view.on('closed', () => view.removeListener('target-changed', reparentHandler));
                    });
                    // Not yet implemented
                    // provider.register('close-window', ({target}) => closeWindow(target));
                    // provider.register('get-all-windows', getAllWindows);
                    // provider.register('get-all-views', getAllViews);
                    const willRestore = localStorage.getItem('user-snapshot');
                    let modifiedInitialConfig;
                    await Promise.all([startupRunRequestedPromise, startupWindowClosePromise]);
                    dispatchPlatformEvent('platform-api-ready');
                    if (willRestore) {
                        // restore saved snapshot if exists from user prompt
                        modifiedInitialConfig = await convertSnapshotWindowOptions(JSON.parse(willRestore));
                    }
                    else if (appManifestUrl) {
                        // need to have the core fetch the appManifestUrl and emit run-requested
                        fin.Platform.getCurrentSync().launchContentManifest(appManifestUrl);
                        return;
                    }
                    else {
                        // set initial config from app manifest
                        const { snapshot } = initialAppOptions;
                        if (snapshot) {
                            modifiedInitialConfig = await convertSnapshotWindowOptions(snapshot);
                        }
                    }
                    if (modifiedInitialConfig) {
                        await platformProvider.applySnapshot({ snapshot: modifiedInitialConfig }, fin.me.identity);
                    }
                    resolve(platformProvider);
                }
                catch (err) {
                    reject(err);
                }
            });
        });
    };
}
exports.default = initConstructor;
// Type defs for jsdoc
/**
 * ApplySnapshotOptions interface
 * @typedef { object } ApplySnapshotOptions
 * @property { boolean } [closeExistingWindows=false] When true, applySnapshot will close existing windows,
 * replacing current Platform state with the given snapshot.
 * @property { boolean } [skipOutOfBoundsCheck=false] When true, applySnapshot will not check whether any windows in a
 * snapshot are off-screen. By default, such windows will be repositioned to be on-screen,
 * as defined by {@link PlatformProvider#positionOutOfBoundsWindows PlatformProvider.positionOutOfBoundsWindows}.
 */
/**
 * Payload sent to Platform Provider when {@link Platform#applySnapshot Platform.applySnapshot} is called.
 * @typedef { object } ApplySnapshotPayload
 * @property { Snapshot } snapshot The snapshot to be applied.
 * @property { ApplySnapshotOptions } [options] Options to customize snapshot application.
 */
/**
 * CreateViewPayload interface
 * @typedef { object } CreateViewPayload
 * @property { View~options } opts Options for the view to be added.
 * @property { Identity } [target] Window the view will be added to. If no target is provided, a new window will be created.
 */
/**
 * CloseViewPayload interface
 * @typedef { object } CloseViewPayload
 * @property { Identity } target View to be closed.
 */
/**
 * FetchManifestPayload interface
 * @typedef { object } FetchManifestPayload
 * @property { string } manifestUrl The URL of the manifest to fetch.
 */
/**
 * ReplaceLayoutOpts interface
 * @typedef { object } ReplaceLayoutOpts
 * @property { LayoutConfig } layout Layout config to be applied.
 */
/**
 * ReplaceLayoutPayload interface
 * @typedef { object } ReplaceLayoutPayload
 * @property { ReplaceLayoutOpts } opts Object containing the layout to be applied.
 * @property { Identity } target Identity of the window whose layout will be replace.
 */
/**
 * SetWindowContextPayload interface
 * @typedef { object } SetWindowContextPayload
 * @property { any } context The requested context update.
 * @property { EntityType } entityType Entity type of the target of the context update ('view' or 'window').
 * @property { Identity } target Identity of the entity targeted by the call to {@link Platform#setWindowContext Platform.setWindowContext}.
 */
/**
 * SetWindowContextPayload interface
 * @typedef { object } SetWindowContextPayload
 * @property { any } context The requested context update.
 * @property { EntityType } entityType Entity type of the target of the context update ('view' or 'window').
 * @property { Identity } target Identity of the entity targetted by the call to
 * {@link Platform#setWindowContext Platform.setWindowContext}.
 */
/**
 * GetWindowContextPayload interface
 * @typedef { object } GetWindowContextPayload
 * @property { EntityType } entityType Entity type of the target of the context update ('view' or 'window').
 * @property { Identity } target Identity of the entity targeted by the call to {@link Platform#getWindowContext Platform.getWindowContext}.
 */
/**
 * HostContextChangedPayload interface
 * @typedef { object } HostContextChangedPayload
 * @property { any } context The new context object
 * @property { string } reason The reason for the update: 'updated' or 'reparented'
 */
