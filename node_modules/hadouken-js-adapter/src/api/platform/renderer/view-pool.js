"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupViewPool = exports.getPooledViewObject = exports.detachOrCloseView = void 0;
let viewPoolArray = [];
exports.detachOrCloseView = async (ofView) => {
    const { uuid } = ofView.identity;
    const { detachOnClose } = await ofView.getOptions();
    if (detachOnClose) {
        await ofView.attach({ uuid, name: uuid });
        return ofView.hide();
    }
    return ofView.destroy();
};
exports.getPooledViewObject = async () => {
    const views = await fin.Window.getCurrentSync().getCurrentViews();
    return views.reduce((carry, view) => ({ ...carry, [view.identity.name]: true }), {});
};
function removeFromPool(identity) {
    viewPoolArray = viewPoolArray.filter((poolIdentity) => poolIdentity.name !== identity.name);
}
function setupViewPool(maxViewPoolSize) {
    // Currently, all this function does is enforce a maximimum number of views in the pool
    const ofWindow = fin.Window.getCurrentSync();
    ofWindow.on('view-detached', ({ viewIdentity }) => removeFromPool(viewIdentity));
    ofWindow.on('view-destroyed', ({ viewIdentity }) => removeFromPool(viewIdentity));
    ofWindow.on('view-target-changed', async (payload) => {
        const { viewIdentity } = payload;
        viewPoolArray = [...viewPoolArray, viewIdentity];
        if (viewPoolArray.length > maxViewPoolSize) {
            const removeView = viewPoolArray[0];
            console.warn(`Max View Pool size of ${maxViewPoolSize} reached, destroying view: ${JSON.stringify(removeView)}.`);
            removeFromPool(removeView);
            fin.View.wrapSync(removeView).destroy();
        }
    });
}
exports.setupViewPool = setupViewPool;
