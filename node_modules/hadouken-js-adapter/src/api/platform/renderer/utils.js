"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMaximizedContentItem = exports.unmaximizeLayout = exports.isLayoutMaximized = exports.detachOrCloseView = exports.showCloseButtonsIfClosable = exports.getOutOfBoundsWindows = exports.promisifyViewLoadEvents = exports.buildFailedEventPayload = exports.getComponentBounds = exports.updateViewState = exports.setViewBoundsByRect = exports.setFallbackBodyAndTitle = exports.setTabTitle = exports.setContainerMessage = exports.mock = exports.compareIdentities = exports.getOutOfWindowDropBounds = exports.handleRenderError = exports.getDragPayload = exports.generateLayoutContent = exports.delay = exports.debounce = exports.createComponent = exports.generatePresetLayoutContent = exports.getPresetLayoutFunction = exports.generateTabsPreset = exports.emitLocalEvent = exports.addComponentToContentItem = void 0;
/* global CustomEvent getComputedStyle */
const base32 = require("hi-base32");
exports.addComponentToContentItem = (component, target) => {
    const { componentState } = component;
    const newComponent = createComponent(componentState);
    target.content.push(newComponent);
};
// eslint-disable-next-line @typescript-eslint/explicit-function-return-type
const buildLocalEventPayload = (event, identity) => ({
    ...identity,
    type: event,
    topic: 'openfin-DOM-event',
    tabSelector: `tab-${identity.name}`,
    containerSelector: `container-${identity.name}`
});
exports.emitLocalEvent = (event, identity, container) => {
    if (identity.name === 'internal-usage-to-be-replaced') {
        // this is used internally to reparent views
        return;
    }
    const newPayload = buildLocalEventPayload(event, identity);
    const localEvent = new CustomEvent(event, { detail: newPayload });
    container.dispatchEvent(localEvent);
};
const generateGridPreset = (components) => {
    const count = components.length;
    let current = 0;
    const updatedContent = [];
    const addNextComponent = (target) => {
        const component = components[current];
        exports.addComponentToContentItem(component, target);
        current += 1;
    };
    const rows = Math.ceil(Math.sqrt(count));
    const minCols = Math.floor(count / rows);
    for (let i = 0; i < rows; i += 1) {
        // create a new row
        const newRow = createEmptyItemConfig('row');
        // push view components into that row
        for (let j = 0; j < minCols; j += 1) {
            addNextComponent(newRow);
        }
        // add the row to the content to be added to the top-level column content object
        updatedContent.push(newRow);
    }
    let remainder = count - current;
    // deal with any remaining view contents that haven't been placed
    while (remainder) {
        addNextComponent(updatedContent[rows - remainder]);
        remainder -= 1;
    }
    const topContentItem = createEmptyItemConfig('column');
    topContentItem.content = updatedContent;
    return {
        content: [topContentItem]
    };
};
exports.generateTabsPreset = (components, activeItemIndex) => {
    const updatedContent = createEmptyItemConfig('stack');
    updatedContent.activeItemIndex = activeItemIndex || 0;
    components.forEach((c) => exports.addComponentToContentItem(c, updatedContent));
    const topContentItem = createEmptyItemConfig('row');
    topContentItem.content.push(updatedContent);
    return {
        content: [topContentItem]
    };
};
const generateRowsPreset = (components) => {
    const updatedContent = createEmptyItemConfig('column');
    components.forEach((c) => exports.addComponentToContentItem(c, updatedContent));
    return {
        content: [updatedContent]
    };
};
const generateColumnsPreset = (components) => {
    const updatedContent = createEmptyItemConfig('row');
    components.forEach((c) => exports.addComponentToContentItem(c, updatedContent));
    return {
        content: [updatedContent]
    };
};
exports.getPresetLayoutFunction = {
    ["columns" /* columns */]: generateColumnsPreset,
    ["grid" /* grid */]: generateGridPreset,
    ["rows" /* rows */]: generateRowsPreset,
    ["tabs" /* tabs */]: exports.generateTabsPreset
};
exports.generatePresetLayoutContent = (components, type) => {
    return exports.getPresetLayoutFunction[type](components);
};
function createComponent(componentState) {
    return {
        type: 'component',
        componentName: 'view',
        componentState
    };
}
exports.createComponent = createComponent;
function createEmptyItemConfig(type) {
    return {
        type,
        content: []
    };
}
const cssValToNumber = (cssVal) => Number(cssVal.replace('px', ''));
exports.debounce = (callback, delay, resizing) => {
    let timeout;
    return (...args) => {
        clearTimeout(timeout);
        if (!resizing) {
            timeout = setTimeout(() => callback(...args), delay);
        }
    };
};
exports.delay = (delayMilliseconds) => new Promise((resolve) => setTimeout(resolve, delayMilliseconds));
exports.generateLayoutContent = (componentState) => {
    const component = createComponent(componentState);
    return {
        content: [
            {
                type: 'stack',
                content: [component]
            }
        ],
        maximisedItemId: null
    };
};
exports.getDragPayload = (e) => {
    var _a, _b;
    const PAYLOAD_PREFIX = 'payload:';
    // Payload is encoded in dataTransfer.types, to make it available on dragover events.
    const payloadType = (_b = (_a = e.originalEvent) === null || _a === void 0 ? void 0 : _a.dataTransfer) === null || _b === void 0 ? void 0 : _b.types.find((type) => type.startsWith(PAYLOAD_PREFIX));
    if (!payloadType) {
        return null;
    }
    // dataTransfer.type is coerced to lowercase. To mitigate this, payload is in base32 encoding
    const base32Payload = payloadType.substring(PAYLOAD_PREFIX.length).toUpperCase();
    return JSON.parse(base32.decode(base32Payload));
};
function handleRenderError(component, e) {
    setContainerMessage(component.container, e.message);
}
exports.handleRenderError = handleRenderError;
exports.getOutOfWindowDropBounds = (e, container, dimensions) => {
    let containerTop = 0;
    let containerPaddingTop = 0;
    let containerPaddingBottom = 0;
    let tabHeight = 0;
    let horizontalPadding = 0;
    try {
        containerTop = container.getBoundingClientRect().top;
        const { paddingTop, paddingBottom, paddingLeft, paddingRight } = getComputedStyle(container);
        containerPaddingTop = cssValToNumber(paddingTop);
        containerPaddingBottom = cssValToNumber(paddingBottom);
        horizontalPadding = cssValToNumber(paddingLeft) + cssValToNumber(paddingRight);
        tabHeight = cssValToNumber(getComputedStyle(container.querySelector('.lm_header')).height);
    }
    catch (err) {
        console.error('Error getting dimensions for tearout window: ', err);
    }
    const offsetY = containerTop + containerPaddingTop + 4; // Place mouse in new window's tab, not exactly at top
    const offsetX = 20; // Place mouse over tab, not exactly at left
    const top = Math.max(e.screenY - offsetY, 0);
    const left = Math.max(e.screenX - offsetX, 0);
    const { width, height } = dimensions;
    const newWindowWidth = width + horizontalPadding;
    const newWindowHeight = height + containerPaddingTop + containerPaddingBottom + containerTop + tabHeight; // preserve view height
    const bounds = {
        top,
        left,
        width: 0,
        height: 0
    };
    if (newWindowWidth && newWindowHeight) {
        bounds.width = newWindowWidth;
        bounds.height = newWindowHeight;
    }
    return bounds;
};
exports.compareIdentities = (sourceIdentity, currentWindow) => {
    const { uuid: sourceUuid, name: sourceName } = sourceIdentity || {};
    const { uuid: targetUuid, name: targetName } = currentWindow;
    const isSameApp = sourceUuid === targetUuid;
    return {
        isSameApp,
        isSameWindow: sourceName === targetName && isSameApp
    };
};
exports.mock = {
    on: () => {
        // empty block
    }
};
function setContainerMessage(container, message) {
    if (!container) {
        throw new Error('could not get tab container');
    }
    const containerDiv = container.getElement()[0];
    const openfinDiv = containerDiv.getElementsByClassName('openfin_default_background')[0];
    if (!openfinDiv) {
        console.warn(`Div with class 'openfin_default_background' has been removed, container message not set:
            ${message}`);
        return;
    }
    openfinDiv.innerHTML = `<div class="wrapper_title">${message}</div>`;
}
exports.setContainerMessage = setContainerMessage;
function setTabTitle(tab, title) {
    const { container } = tab.contentItem;
    if (!container) {
        throw new Error('could not get tab container');
    }
    let updatedTitle = title;
    if (!title) {
        const state = container.getState();
        const url = new URL(state.url);
        updatedTitle = state.title || url.hostname || state.url || state.name;
    }
    container.setTitle(updatedTitle);
}
exports.setTabTitle = setTabTitle;
function setFallbackBodyAndTitle(viewComponent) {
    setTabTitle(viewComponent.container.tab, undefined);
    const url = new URL(viewComponent.componentState.url);
    setContainerMessage(viewComponent.container, url.hostname);
}
exports.setFallbackBodyAndTitle = setFallbackBodyAndTitle;
exports.setViewBoundsByRect = async (rect, ofView) => {
    try {
        await ofView.setBounds({
            height: Math.floor(rect.height),
            width: Math.floor(rect.width),
            top: Math.floor(rect.top),
            left: Math.floor(rect.left)
        });
        return ofView;
    }
    catch (e) {
        // uncomment next line for any platforms view weirdness
        // console.error('error setting view bounds', e);
        return ofView;
    }
};
exports.updateViewState = async (viewComponent, ofView) => {
    const { componentState, container } = viewComponent;
    const { customContext, url: initialUrl, customData, processAffinity } = await ofView.getOptions();
    let { url } = await ofView.getInfo();
    if (!url) {
        // if snapshot/config is taken prior to navigation, url from getInfo will be blank
        url = initialUrl;
    }
    const newState = {
        ...componentState,
        url,
        customContext,
        customData,
        initialUrl,
        processAffinity
    };
    container.setState(newState);
};
const getDOMElementFromComponent = (bv) => bv.container.getElement()[0];
exports.getComponentBounds = (bv) => getDOMElementFromComponent(bv).getBoundingClientRect();
exports.buildFailedEventPayload = (response, identity) => {
    return { success: false, response, identity };
};
exports.promisifyViewLoadEvents = (view, windowIdentity) => {
    // whichever one of these events fires first will resolve the view's load status.
    const loadCompletedOrFailedEvents = [
        'destroyed',
        'target-changed',
        'navigation-rejected',
        'did-fail-load',
        'did-fail-provisional-load',
        'crashed',
        'did-finish-load'
    ];
    return new Promise((resolve) => {
        const handleResponseEvent = (payload) => {
            let response;
            const { identity } = view;
            const { type, target, errorCode, reason } = payload;
            if (type === 'target-changed' &&
                target &&
                target.uuid === windowIdentity.uuid &&
                target.name === windowIdentity.name) {
                resolve({ success: true, identity }); // the view just moved where we wanted it. no action needed.
                return;
            }
            switch (type) {
                case 'did-fail-load':
                case 'did-fail-provisional-load': {
                    const errMsg = `view navigation failed with error ${errorCode}.
                        see https://cs.chromium.org/chromium/src/net/base/net_error_list.h for more information.`;
                    response = exports.buildFailedEventPayload(errMsg, identity);
                    break;
                }
                case 'destroyed':
                    response = exports.buildFailedEventPayload('view destroyed before ready event.', identity);
                    break;
                case 'target-changed':
                    response = exports.buildFailedEventPayload('view reparented to a different window before ready event.', identity);
                    break;
                case 'navigation-rejected':
                    response = exports.buildFailedEventPayload('view navigation rejected due to whitelist/blacklist rules.', identity);
                    break;
                case 'crashed':
                    response = exports.buildFailedEventPayload(`view crashed. reason: ${reason}`, identity);
                    break;
                case 'did-finish-load':
                    response = { success: true, identity };
                    break;
                default:
                    response = exports.buildFailedEventPayload('Unknown load error.', identity);
            }
            removeAllCreationListeners();
            resolve(response);
        };
        function removeAllCreationListeners() {
            loadCompletedOrFailedEvents.forEach((eventName) => view.removeListener(eventName, handleResponseEvent));
        }
        function addAllCreationListeners() {
            loadCompletedOrFailedEvents.forEach((eventName) => view.addListener(eventName, handleResponseEvent));
        }
        addAllCreationListeners();
    });
};
exports.getOutOfBoundsWindows = async (snapshot, monitorInfo) => {
    const { primaryMonitor, nonPrimaryMonitors } = monitorInfo;
    const availableRects = [primaryMonitor.availableRect, ...nonPrimaryMonitors.map((info) => info.availableRect)];
    const outOfBoundsWindows = snapshot.windows.filter((window) => {
        const { defaultLeft, defaultTop, defaultWidth, defaultHeight } = window;
        return !availableRects.some((rect) => {
            const { left, right, top, bottom } = rect;
            return (left <= defaultLeft &&
                top <= defaultTop &&
                right >= defaultLeft + defaultWidth &&
                bottom >= defaultTop + defaultHeight);
        });
    });
    return outOfBoundsWindows;
};
exports.showCloseButtonsIfClosable = (layout) => {
    layout.root.getItemsByType('stack').forEach((stack) => {
        const stackItems = stack.contentItems;
        let isStackClosable = true;
        stackItems.forEach((item) => {
            const closeTabButton = item.container.tab.element.find('.lm_close_tab');
            if (!item.container.getState().isClosable) {
                isStackClosable = false;
                closeTabButton.hide();
            }
            else {
                closeTabButton.show();
            }
        });
        const closeStackButton = stack.element.find('.lm_close');
        if (isStackClosable) {
            closeStackButton.show();
        }
        else {
            closeStackButton.hide();
        }
    });
};
exports.detachOrCloseView = async (ofView) => {
    const { uuid } = ofView.identity;
    const { detachOnClose } = await ofView.getOptions();
    if (detachOnClose) {
        return ofView.attach({ uuid, name: uuid });
    }
    return ofView.destroy();
};
exports.isLayoutMaximized = (layout) => {
    const rootChildren = Array.from(layout.root.element[0].children);
    return rootChildren.some((childNode) => childNode.classList.contains('lm_maximised'));
};
exports.unmaximizeLayout = (layout) => {
    if (exports.isLayoutMaximized(layout)) {
        const maximizedStack = layout.root.getItemsById('__glMaximised')[0];
        maximizedStack.toggleMaximise();
    }
};
exports.getMaximizedContentItem = (layout) => {
    if (exports.isLayoutMaximized(layout)) {
        return layout.root.getItemsById('__glMaximised')[0].getActiveContentItem();
    }
    return null;
};
