"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.detachView = exports.setUpKeyboardCommands = exports.mergeDefaultCommands = exports.handleWindowCommand = exports.handleViewCommand = void 0;
const utils_1 = require("./utils");
const nthTabRegex = /stack\.nth-tab-([1-9])$/;
const NEW_WINDOW_EDGE_OFFSET = 80;
const DEFAULT_KEYBOARD_COMMANDS = [
    {
        command: 'stack.nextTab',
        keys: 'Ctrl+Tab'
    },
    {
        command: 'stack.previousTab',
        keys: 'Ctrl+Shift+Tab'
    },
    {
        command: 'view.zoomIn',
        keys: 'Ctrl+='
    },
    {
        command: 'view.zoomOut',
        keys: 'Ctrl+-'
    },
    {
        command: 'view.zoomReset',
        keys: 'Ctrl+0'
    },
    {
        command: 'view.detach',
        keys: 'Ctrl+Shift+D'
    },
    {
        command: 'view.focusLeft',
        keys: 'Ctrl+Shift+Left'
    },
    {
        command: 'view.focusRight',
        keys: 'Ctrl+Shift+Right'
    },
    {
        command: 'view.focusUp',
        keys: 'Ctrl+Shift+Up'
    },
    {
        command: 'view.focusDown',
        keys: 'Ctrl+Shift+Down'
    }
];
exports.handleViewCommand = async (e, bv, context) => {
    if (e.inputType !== 'keyUp' || !e.command) {
        return;
    }
    const commandName = e.command;
    const { tab } = bv.container;
    const ofView = context.getOfViewFromComponentState(bv.componentState);
    const stack = tab.header.parent;
    const totalTabs = stack.contentItems.length;
    if (nthTabRegex.test(commandName)) {
        switchToNthTab(commandName, stack, totalTabs);
        return;
    }
    switch (commandName) {
        case 'stack.nextTab':
        case 'stack.previousTab': // navigate between tabs using keyboard
            switchToNextOrPrevTab(stack, commandName, totalTabs);
            break;
        case 'stack.close':
            context.onStackCloseClick(stack);
            break;
        case 'stack.closeTab':
            context.onCloseTabButtonClick(tab);
            break;
        case 'stack.maximize':
            stack.toggleMaximise();
            break;
        case 'stack.popout':
            context.onPopoutClick(stack);
            break;
        case 'view.zoomIn':
        case 'view.zoomOut':
        case 'view.zoomReset':
            await changeZoomLevel(commandName, ofView);
            break;
        case 'view.detach':
            detachView(tab, context);
            break;
        case 'view.focusLeft':
        case 'view.focusRight':
        case 'view.focusUp':
        case 'view.focusDown': {
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            focusOnAdjacentView(commandName, bv, context);
            break;
        }
        // no default
    }
};
exports.handleWindowCommand = (e, context) => {
    if (e.inputType !== 'keyUp' || !e.command) {
        return;
    }
    const commandName = e.command;
    switch (commandName) {
        case 'stack.nextTab':
        case 'stack.previousTab': {
            // navigate between tabs using keyboard
            const stacks = context.layout.root.getItemsByType('stack');
            const multiTabStack = stacks.find((s) => s.contentItems.length > 1);
            if (multiTabStack) {
                const activeTabIndex = multiTabStack.contentItems.indexOf(multiTabStack.getActiveContentItem());
                exports.handleViewCommand(e, multiTabStack.getComponentsByName('view')[activeTabIndex], context);
            }
            break;
        }
        // no default
    }
};
const getTabNavigationCommands = (modifiers = 'Ctrl') => {
    const tabNums = [1, 2, 3, 4, 5, 6, 7, 8, 9];
    return tabNums.map((num) => ({
        command: `stack.nth-tab-${num}`,
        keys: `${modifiers}+${num}`
    }));
};
exports.mergeDefaultCommands = (providedCommands) => {
    // create a map of commands that user wants to override
    const providedCommandsMap = providedCommands.reduce((acc, commandItem) => {
        acc[commandItem.command] = true;
        return acc;
    }, {});
    const defaultsAfterOverwriting = DEFAULT_KEYBOARD_COMMANDS.filter((commandItem) => !providedCommandsMap[commandItem.command]);
    if (providedCommandsMap['stack.nth-tab']) {
        const overwriteCommand = providedCommands.find((c) => c.command === 'stack.nth-tab');
        if (overwriteCommand.keys) {
            defaultsAfterOverwriting.push(...getTabNavigationCommands(overwriteCommand.keys));
        }
    }
    else {
        // if `go to nth-tab` behavior isn't specified/disabled, default is Ctrl+[1-9]
        defaultsAfterOverwriting.push(...getTabNavigationCommands());
    }
    providedCommands = providedCommands.filter((commandItem) => {
        // filter out user-disabled commands
        const isEmpty = !commandItem.keys;
        // remove override entry
        const isDisposableOverride = commandItem.command === 'stack.nth-tab';
        return !isEmpty && !isDisposableOverride;
    });
    return [...defaultsAfterOverwriting, ...providedCommands];
};
exports.setUpKeyboardCommands = (defaultHotkeys, hotkeys, appOptions) => {
    hotkeys = Array.isArray(hotkeys) ? hotkeys : [];
    defaultHotkeys = Array.isArray(defaultHotkeys) ? defaultHotkeys : [];
    if (hotkeys.some((h) => h.command)) {
        return hotkeys;
    } // commands are already set up
    let commands = Array.isArray(appOptions.commands) ? appOptions.commands : [];
    if (!appOptions.disableDefaultCommands) {
        commands = exports.mergeDefaultCommands(commands);
    }
    defaultHotkeys = defaultHotkeys.filter((defaultHotkey) => !hotkeys.some((hotkey) => hotkey.keys === defaultHotkey.keys));
    return [...defaultHotkeys, ...hotkeys, ...commands];
};
function switchToNthTab(commandName, stack, totalTabs) {
    const tabNumber = +commandName.match(nthTabRegex)[1];
    if (tabNumber === 9) {
        const lastTab = stack.contentItems[stack.contentItems.length - 1];
        stack.setActiveContentItem(lastTab);
    }
    else if (tabNumber - 1 < totalTabs) {
        const nthTab = stack.contentItems[tabNumber - 1];
        stack.setActiveContentItem(nthTab);
    }
}
function detachView(tab, context) {
    if (context.getViewComponents().length <= 1) {
        return;
    }
    const contentBounds = tab.contentItem.element[0].getBoundingClientRect();
    const dimensions = {
        height: contentBounds.height,
        width: contentBounds.height
    };
    let deltaX = NEW_WINDOW_EDGE_OFFSET;
    let deltaY = NEW_WINDOW_EDGE_OFFSET;
    // if window is too close to the right edge, move it left
    if (window.screenX + window.outerWidth + deltaX > window.screen.width) {
        deltaX *= -1;
    }
    // if window is too close to the bottom edge, move it up
    if (window.screenY + window.outerHeight + deltaY > window.screen.height) {
        deltaY *= -1;
    }
    const newScreenPosition = {
        left: window.screenX + contentBounds.left + deltaX,
        top: window.screenY + contentBounds.top + deltaY
    };
    context.handleOutOfWindowDrop({ screenX: newScreenPosition.left, screenY: newScreenPosition.top }, tab, dimensions);
}
exports.detachView = detachView;
async function changeZoomLevel(commandName, ofView) {
    if (commandName === 'view.zoomReset') {
        await ofView.setZoomLevel(0);
    }
    else {
        const currentZoomLevel = await ofView.getZoomLevel();
        const delta = commandName === 'view.zoomIn' ? 0.5 : -0.5;
        await ofView.setZoomLevel(currentZoomLevel + delta);
    }
}
function switchToNextOrPrevTab(stack, commandName, totalTabs) {
    const currentTabIndex = stack.contentItems.indexOf(stack.getActiveContentItem());
    let nextIndex = currentTabIndex;
    if (commandName === 'stack.previousTab') {
        // go to prev. tab
        nextIndex = currentTabIndex > 0 ? nextIndex - 1 : totalTabs - 1;
    }
    else {
        // go to next tab
        nextIndex = currentTabIndex < totalTabs - 1 ? nextIndex + 1 : 0;
    }
    stack.setActiveContentItem(stack.contentItems[nextIndex]);
}
const distanceFromTo = (pointA, pointB) => {
    // using geometric distance formula
    return Math.sqrt((pointA.x - pointB.x) ** 2 + (pointA.y - pointB.y) ** 2);
};
const getCenterCoords = (bv) => {
    const componentBounds = utils_1.getComponentBounds(bv);
    const y = componentBounds.y + componentBounds.height / 2;
    const x = componentBounds.x + componentBounds.width / 2;
    return { x, y, componentBounds };
};
const getComponentClosestTo = (givenComponent, components, coordGen) => {
    const center = getCenterCoords(givenComponent);
    let leastDistance = Number.MAX_VALUE;
    let closestComponent;
    components.forEach((component) => {
        const bounds = utils_1.getComponentBounds(component);
        const distance = distanceFromTo(center, coordGen(bounds));
        if (distance < leastDistance) {
            closestComponent = component;
            leastDistance = distance;
        }
    });
    return closestComponent;
};
// returns potential focus targets based on relative position (e.g. all components below current one when moving down)
const getFocusCandidates = (components, bv, relativePositionFilter) => {
    const currentBounds = utils_1.getComponentBounds(bv);
    components = components.filter((component) => {
        const bounds = utils_1.getComponentBounds(component);
        return (component.componentState.name !== bv.componentState.name &&
            bounds.width !== 0 &&
            relativePositionFilter(currentBounds, bounds));
    });
    return components;
};
const focusOnAdjacentView = (command, currentView, context) => {
    // used to filter views based on their relative position
    // e.g. only compare distances to views to left of current view when moving left
    let boundsFilter;
    // depending on direction of focus move, we need to compare different parts of candidate bounds
    // e.g. when moving left, we compare distance from right-middle of a candidate component
    let comparisonCoordGenerator;
    switch (command) {
        case 'view.focusLeft': {
            boundsFilter = (current, candidate) => candidate.right < current.left;
            comparisonCoordGenerator = (bounds) => ({ x: bounds.right, y: bounds.top + bounds.height / 2 });
            break;
        }
        case 'view.focusRight': {
            boundsFilter = (current, candidate) => candidate.left > current.right;
            comparisonCoordGenerator = (bounds) => ({ x: bounds.left, y: bounds.top + bounds.height / 2 });
            break;
        }
        case 'view.focusUp': {
            boundsFilter = (current, candidate) => current.top > candidate.bottom;
            comparisonCoordGenerator = (bounds) => ({ x: bounds.left + bounds.width / 2, y: bounds.bottom });
            break;
        }
        case 'view.focusDown': {
            boundsFilter = (current, candidate) => current.bottom < candidate.top;
            comparisonCoordGenerator = (bounds) => ({ x: bounds.left + bounds.width / 2, y: bounds.top });
            break;
        }
        // no default
    }
    const components = getFocusCandidates(context.getViewComponents(), currentView, boundsFilter);
    if (components.length === 0) {
        return; // nowhere to move focus (i.e. current view is farthest on left/right/top/bottom)
    }
    const closestComponent = getComponentClosestTo(currentView, components, comparisonCoordGenerator);
    const view = context.getOfViewFromComponentState(closestComponent.componentState);
    view.focus();
};
