"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = require("../base");
const validate_1 = require("../../util/validate");
const Instance_1 = require("./Instance");
/**
 * @lends Frame
 */
class _FrameModule extends base_1.Base {
    /**
     * Asynchronously returns a reference to the specified frame. The frame does not have to exist
     * @param {Identity} identity - the identity of the frame you want to wrap
     * @return {Promise.<_Frame>}
     * @tutorial Frame.wrap
     * @static
     */
    async wrap(identity) {
        try {
            this.wire.sendAction('frame-wrap');
        }
        catch (e) {
            // we do not want to expose this error, just continue if this analytics-only call fails
        }
        const errorMsg = validate_1.validateIdentity(identity);
        if (errorMsg) {
            throw new Error(errorMsg);
        }
        return new Instance_1._Frame(this.wire, identity);
    }
    /**
     * Synchronously returns a reference to the specified frame. The frame does not have to exist
     * @param {Identity} identity - the identity of the frame you want to wrap
     * @return {_Frame}
     * @tutorial Frame.wrapSync
     * @static
     */
    wrapSync(identity) {
        try {
            this.wire.sendAction('frame-wrap-sync');
        }
        catch (e) {
            // we do not want to expose this error, just continue if this analytics-only call fails
        }
        const errorMsg = validate_1.validateIdentity(identity);
        if (errorMsg) {
            throw new Error(errorMsg);
        }
        return new Instance_1._Frame(this.wire, identity);
    }
    /**
     * Asynchronously returns a reference to the current frame
     * @return {Promise.<_Frame>}
     * @tutorial Frame.getCurrent
     * @static
     */
    getCurrent() {
        try {
            this.wire.sendAction('frame-get-current');
        }
        catch (e) {
            // we do not want to expose this error, just continue if this analytics-only call fails
        }
        return Promise.resolve(new Instance_1._Frame(this.wire, this.wire.environment.getCurrentEntityIdentity()));
    }
    /**
     * Synchronously returns a reference to the current frame
     * @return {_Frame}
     * @tutorial Frame.getCurrentSync
     * @static
     */
    getCurrentSync() {
        try {
            this.wire.sendAction('frame-get-current-sync');
        }
        catch (e) {
            // we do not want to expose this error, just continue if this analytics-only call fails
        }
        return new Instance_1._Frame(this.wire, this.wire.environment.getCurrentEntityIdentity());
    }
}
exports.default = _FrameModule;
