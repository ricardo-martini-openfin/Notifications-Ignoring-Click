"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveDir = exports.first = exports.resolveRuntimeVersion = exports.rmDir = exports.unzip = exports.exists = void 0;
const path = require("path");
const fs = require("fs");
const child_process_1 = require("child_process");
const promises_1 = require("../util/promises");
const http_1 = require("../util/http");
const stat = promises_1.promisify(fs.stat);
async function exists(filePath) {
    try {
        const existed = await stat(filePath);
        return Boolean(existed);
    }
    catch (e) {
        return false;
    }
}
exports.exists = exists;
async function unzip(file, dest) {
    const ex = promises_1.promisify(child_process_1.exec);
    return ex(`unzip ${file} -d ${dest}`, { encoding: 'utf8' });
}
exports.unzip = unzip;
const lstat = promises_1.promisify(fs.lstat);
const unlink = promises_1.promisify(fs.unlink);
const readdir = promises_1.promisify(fs.readdir);
const rmdir = promises_1.promisify(fs.rmdir);
async function rmDir(dirPath, removeSelf = true) {
    let files;
    try {
        files = await readdir(dirPath);
    }
    catch (e) {
        return;
    }
    if (files.length > 0) {
        await promises_1.promiseMap(files, async (f) => {
            const filePath = `${dirPath}/${f}`;
            const file = await lstat(filePath);
            if (file.isFile() || file.isSymbolicLink()) {
                await unlink(filePath);
            }
            else {
                await rmDir(filePath, true);
            }
        });
    }
    if (removeSelf) {
        await rmdir(dirPath);
    }
}
exports.rmDir = rmDir;
async function resolveRuntimeVersion(versionOrChannel) {
    const splitVersion = versionOrChannel.split('.');
    const isVersion = splitVersion.length > 1 && splitVersion.every((x) => x === '*' || /^\d+$/.test(x));
    if (isVersion) {
        const mustMatch = takeWhile(splitVersion, (x) => x !== '*');
        if (4 - mustMatch.length > 0) {
            const res = await http_1.fetch('https://cdn.openfin.co/release/runtimeVersions');
            const versions = res.split('\n');
            const match = first(versions, (v) => v.split('.').slice(0, mustMatch.length).join('.') === mustMatch.join('.'));
            if (match) {
                return match;
            }
        }
        else {
            return versionOrChannel;
        }
    }
    try {
        return await http_1.fetch(`https://cdn.openfin.co/release/runtime/${versionOrChannel}`);
    }
    catch (err) {
        throw Error('Could not resolve runtime version');
    }
}
exports.resolveRuntimeVersion = resolveRuntimeVersion;
function first(arr, func) {
    for (let i = 0; i < arr.length; i++) {
        if (func(arr[i], i, arr)) {
            return arr[i];
        }
    }
    return null;
}
exports.first = first;
function takeWhile(arr, func) {
    return arr.reduce(({ take, vals }, x, i, r) => take && func(x, i, r) ? { take: true, vals: [...vals, x] } : { take: false, vals }, { take: true, vals: [] }).vals;
}
const mkdir = promises_1.promisify(fs.mkdir);
async function resolveDir(base, paths) {
    return paths.reduce(async (p, next) => {
        try {
            const prev = await p;
            await mkdir(path.resolve(prev, next));
            return path.join(prev, next);
        }
        catch (err) {
            return err.code === 'EEXIST' ? err.path : Promise.reject(err);
        }
    }, Promise.resolve(base));
}
exports.resolveDir = resolveDir;
