"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchJson = exports.downloadFile = exports.fetch = exports.getRequestOptions = exports.getProxy = void 0;
const url_1 = require("url");
const fs = require("fs");
const getProxyVar = () => {
    return process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy;
};
exports.getProxy = () => {
    const parsedUrl = new url_1.URL(getProxyVar());
    return {
        port: parsedUrl.port,
        host: parsedUrl.hostname,
        username: parsedUrl.username,
        password: parsedUrl.password
    };
};
exports.getRequestOptions = (url) => {
    const parsedUrl = new url_1.URL(url);
    let options;
    if (getProxyVar() && parsedUrl.hostname !== 'localhost' && parsedUrl.hostname.substring(0, 3) !== '127') {
        options = {};
        const proxy = exports.getProxy();
        options.host = proxy.host;
        options.port = proxy.port;
        options.path = url;
        options.headers = { Host: parsedUrl.hostname };
        if (proxy.username && proxy.password) {
            const auth = `Basic ${Buffer.from(`${proxy.username}:${proxy.password}`).toString('base64')}`;
            Object.assign(options.headers, { 'Proxy-Authorization': auth });
        }
    }
    else {
        options = parsedUrl;
    }
    return options;
};
exports.fetch = async (url) => {
    const requestUrl = getProxyVar() ? getProxyVar() : url;
    const proto = url_1.parse(requestUrl).protocol.slice(0, -1) === 'http' ? 'http' : 'https';
    const fetcher = await Promise.resolve().then(() => require(proto));
    return new Promise((resolve, reject) => {
        const options = exports.getRequestOptions(url);
        const request = fetcher.get(options, (response) => {
            if (response.statusCode < 200 || response.statusCode > 299) {
                reject(new Error(`Failed to load url: ${url}, status code:${response.statusCode}`));
            }
            const body = [];
            response.on('data', (chunk) => {
                body.push(chunk);
            });
            response.on('end', () => resolve(body.join('')));
        });
        request.on('error', (err) => {
            reject(err);
        });
    });
};
exports.downloadFile = async (url, writeLocation) => {
    const requestUrl = getProxyVar() ? getProxyVar() : url;
    const proto = url_1.parse(requestUrl).protocol.slice(0, -1) === 'http' ? 'http' : 'https';
    const fetcher = await Promise.resolve().then(() => require(proto));
    return new Promise((resolve, reject) => {
        try {
            const options = exports.getRequestOptions(url);
            fetcher.get(options, (response) => {
                const file = fs.createWriteStream(writeLocation);
                response.pipe(file);
                file.on('finish', () => {
                    file.close();
                    resolve();
                });
            });
        }
        catch (e) {
            reject(e);
        }
    });
};
exports.fetchJson = async (url) => {
    const res = await exports.fetch(url);
    return JSON.parse(res);
};
