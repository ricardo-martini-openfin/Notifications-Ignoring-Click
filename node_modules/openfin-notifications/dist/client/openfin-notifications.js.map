{"version":3,"sources":["webpack://notifications/webpack/universalModuleDefinition","webpack://notifications/webpack/bootstrap","webpack://notifications/./src/client/internal.ts","webpack://notifications/./src/client/actions.ts","webpack://notifications/./src/client/connection.ts","webpack://notifications/./node_modules/openfin-service-async/index.js","webpack://notifications/./node_modules/openfin-service-async/DeferredPromise.js","webpack://notifications/./src/client/templates/templates.ts","webpack://notifications/./src/client/index.ts","webpack://notifications/./node_modules/events/events.js","webpack://notifications/./node_modules/openfin-service-async/async.js","webpack://notifications/./src/client/EventRouter.ts","webpack://notifications/./src/client/provider.ts","webpack://notifications/./node_modules/semver-compare/index.js","webpack://notifications/./src/client/validation.ts","webpack://notifications/./src/client/indicator.ts","webpack://notifications/./src/client/forms/index.ts","webpack://notifications/./src/client/forms/fields.ts","webpack://notifications/./src/client/forms/widgets.ts","webpack://notifications/./src/client/templates/index.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","SERVICE_IDENTITY","uuid","SERVICE_CHANNEL","APITopic","ActionTrigger","ActionNoopType","channelPromise","eventEmitter","EventEmitter","hasDOMContentLoaded","DeferredPromise","reconnect","async","launchSystemApp","navigator","appVersion","includes","info","fin","System","getRvmInfo","parseInt","version","split","launchManifest","noUi","catch","error","console","openUrlWithBrowser","e","getServicePromise","promise","msg","Promise","reject","Error","getVersion","then","v","apiVersion","warn","me","identity","Window","timeoutHandle","setTimeout","InterApplicationBus","Channel","connect","wait","payload","channel","clearTimeout","eventRouter","getEventRouter","register","event","dispatchEvent","setDefaultAction","onDisconnection","log","EventRouter","document","readyState","resolve","addEventListener","action","dispatch","__export","res","rej","this","_resolve","_reject","_promise","TemplateNames","markdown","list","provider","NotificationIndicator","IndicatorType","NotificationOptions","VERSION","eventHandler","parseEventWithNotification","notification","date","Date","expires","registerDeserializer","controlSource","controlIndex","rest","trigger","CONTROL","control","eventType","listener","validateEnvironment","sanitizeEventType","sanitizeFunction","count","listenerCount","addListener","tryServiceDispatch","ADD_EVENT_LISTENER","removeListener","REMOVE_EVENT_LISTENER","options","undefined","response","CREATE_NOTIFICATION","valueOf","id","CLEAR_NOTIFICATION","GET_APP_NOTIFICATIONS","map","note","indicator","CLEAR_APP_NOTIFICATIONS","TOGGLE_NOTIFICATION_CENTER","GET_NOTIFICATIONS_COUNT","ReflectOwnKeys","R","Reflect","ReflectApply","apply","target","receiver","args","Function","ownKeys","getOwnPropertySymbols","getOwnPropertyNames","concat","NumberIsNaN","Number","isNaN","init","once","emitter","errorListener","err","resolver","slice","arguments","eventTargetAgnosticAddListener","handler","flags","on","addErrorHandlerIfEventEmitter","_events","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","TypeError","_getMaxListeners","that","_addListener","type","prepend","events","existing","warning","newListener","emit","unshift","push","length","warned","w","String","onceWrapper","fired","wrapFn","_onceWrap","state","wrapped","_listeners","unwrap","evlistener","arr","ret","Array","unwrapListeners","arrayClone","copy","wrapListener","arg","removeEventListener","set","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","doError","er","message","context","len","listeners","prependListener","prependOnceListener","position","originalListener","shift","index","pop","spliceOne","off","removeAllListeners","keys","rawListeners","eventNames","DeferredPromise_1","serialForEach","asyncF","x","parallelForEach","all","untilSignal","signal","predicate","guard","slot","add","remove","allowReject","serialMap","result","serialFilter","parallelMap","parallelFilter","table","filter","withStrictTimeout","timeoutMs","rejectMessage","timeout","race","withTimeout","untilTrue","defaultEmitter","_emitterProviders","_deserializers","_defaultEmitter","targetType","emitterProvider","deserializer","inputEvent","getStatus","GET_PROVIDER_STATUS","connected","status","compare","a","b","pa","pb","na","nb","safeStringify","fallback","JSON","stringify","FieldType","string","number","boolean","StringWidgetType","Text","NumberWidgetType","BooleanWidgetType","Toggle","Checkbox","WidgetType"],"mappings":"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","file":"openfin-notifications.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"notifications\"] = factory();\n\telse\n\t\troot[\"notifications\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n","/**\n * @hidden\n */\n\n/**\n * File contains types used to communicate between client and provider.\n *\n * These types are a part of the client, but are not required by applications wishing to interact with the service.\n * This file is excluded from the public-facing TypeScript documentation.\n */\n\nimport { NotificationActionResult, ActionTrigger } from './actions';\nimport { ProviderStatus } from './provider';\nimport { NotificationSource } from './source';\n\nimport {\n  NotificationOptions,\n  Notification,\n  NotificationActionEvent,\n  NotificationClosedEvent,\n  NotificationCreatedEvent,\n  NotificationsCountChanged,\n  NotificationFormSubmittedEvent,\n} from './index';\n\n/**\n * The identity of the main application window of the service provider\n */\nexport const SERVICE_IDENTITY = {\n  uuid: 'notifications-service',\n  name: 'notifications-service',\n};\n\n/**\n * Name of the IAB channel use to communicate between client and provider\n */\nexport const SERVICE_CHANNEL = 'of-notifications-service-v1';\n\nexport const enum APITopic {\n  CREATE_NOTIFICATION = 'create-notification',\n  CLEAR_NOTIFICATION = 'clear-notification',\n  GET_APP_NOTIFICATIONS = 'fetch-app-notifications',\n  CLEAR_APP_NOTIFICATIONS = 'clear-app-notifications',\n  TOGGLE_NOTIFICATION_CENTER = 'toggle-notification-center',\n  ADD_EVENT_LISTENER = 'add-event-listener',\n  REMOVE_EVENT_LISTENER = 'remove-event-listener',\n  GET_PROVIDER_STATUS = 'get-provider-status',\n  GET_NOTIFICATIONS_COUNT = 'get-notifications-count',\n}\n\nexport interface API {\n  [APITopic.CREATE_NOTIFICATION]: [CreatePayload, NotificationInternal];\n  [APITopic.CLEAR_NOTIFICATION]: [ClearPayload, boolean];\n  [APITopic.CLEAR_APP_NOTIFICATIONS]: [undefined, number];\n  [APITopic.GET_APP_NOTIFICATIONS]: [undefined, NotificationInternal[]];\n  [APITopic.TOGGLE_NOTIFICATION_CENTER]: [undefined, void];\n  [APITopic.ADD_EVENT_LISTENER]: [Events['type'], void];\n  [APITopic.REMOVE_EVENT_LISTENER]: [Events['type'], void];\n  [APITopic.GET_PROVIDER_STATUS]: [undefined, ProviderStatus];\n  [APITopic.GET_NOTIFICATIONS_COUNT]: [undefined, number];\n}\n\nexport type Events =\n  | NotificationActionEvent\n  | NotificationClosedEvent\n  | NotificationCreatedEvent\n  | NotificationsCountChanged\n  | NotificationFormSubmittedEvent;\n\nexport type TransportMappings<T> = T extends NotificationActionEvent\n  ? NotificationActionEventTransport\n  : never;\nexport type TransportMemberMappings<T> = T extends Notification ? NotificationInternal : T;\n\nexport type CreatePayload<T extends NotificationOptions = NotificationOptions> = DistributiveOmit<\n  T,\n  'date' | 'expires'\n> & {\n  date?: number;\n  expires?: number | null;\n};\n\nexport type NotificationInternal<\n  T extends NotificationOptions = NotificationOptions\n> = DistributiveOmit<Notification<T>, 'date' | 'expires'> & {\n  date: number;\n  expires: number | null;\n};\n\nexport interface ClearPayload {\n  id: string;\n}\n\nexport interface NotificationActionEventTransport {\n  type: 'notification-action';\n  notification: Readonly<NotificationInternal>;\n  source: NotificationSource;\n  result: NotificationActionResult;\n  trigger: ActionTrigger;\n\n  // Following are present only if trigger is `ActionTrigger.CONTROL`\n  controlSource?: 'buttons'; // Additional sources will be added in future release\n  controlIndex?: number; // The index of the originating control, within notification[controlSource]\n}\n\n/**\n * Distribute Omit across all union types instead of Omitting the union.\n * https://davidgomes.com/pick-omit-over-union-types-in-typescript/\n */\nexport type DistributiveOmit<T, K extends keyof T> = T extends unknown ? Omit<T, K> : never;\n","/**\n * Actions are the mechanism through which notifications send messages back to the application that created them. The\n * service defines a number of ways in which actions can be raised (a notification being interacted with by the user,\n * being closed, expiring, etc.), and it is up to each application to decide if it wishes to be informed when each of\n * these triggers occur.\n *\n * For an action to be raised when one of these triggers occurs, the application must specify an\n * {@link NotificationActionResult|action result} for each trigger it is interested in. The application should then\n * listen for when these actions are raised by listening for the {@link NotificationActionEvent|`notification-action`}\n * event.\n *\n * This event is fired once each time an action is raised, and will contain the\n * {@link NotificationActionResult|action result} the application specified for that trigger. The application may then\n * use the {@link NotificationActionResult|action result} to determine which trigger occurred and respond appropriately.\n *\n * If an {@link NotificationActionResult|action result} is not specified for a particular trigger, or it is set to\n * `null`, the application will not receive a corresponding {@link NotificationActionEvent|`notification-action`} when\n * that trigger occurs.\n *\n * Unlike other event types, {@link NotificationActionEvent|`notification-action`} events will be buffered by the\n * service until the application has added a listener for this event type, at which point it will receive all buffered\n * {@link NotificationActionEvent|`notification-action`} events. The service will also attempt to restart the\n * application if it is not running when the event is fired.\n *\n * For an overview of actions, consider the sample notification below:\n * ```ts\n * import {addEventListener, create} from 'openfin-notifications';\n *\n * // Create a notification with two buttons\n * create({\n *     // Basic info\n *     title: 'Reminder',\n *     body: 'Event \"Weekly Meeting\" is starting soon...',\n *     category: 'Upcoming Events',\n *\n *     // We'll use the 'customData' field to store metadata about the event\n *     customData: {eventId: '12345'},\n *\n *     // We want the user clicking the notification to open the associated event, so register an 'onSelect' action\n *     onSelect: {task: 'view-calendar-event', target: 'popup'},\n *\n *     buttons: [\n *         // A button that will schedule another reminder for 5 minutes from now. Since the application will be\n *         // responsible for snoozing the event, it will need to know about the user clicking this button. By setting\n *         // a NotificationActionResult for 'onClick', the service will raise a \"notification-action\" event when this\n *         // button is clicked, and will pass the value of 'onClick' as the 'result' field within the event\n *         {\n *             title: 'Snooze for 5 minutes',\n *             iconUrl: 'https://www.example.com/timer.png',\n *             onClick: {\n *                 task: 'schedule-reminder',\n *                 intervalMs: 5 * 60 * 1000\n *             }\n *         },\n *\n *         // A button that closes the notification and doesn't prompt the user about this event again. Since the\n *         // application doesn't need to do anything when the user clicks this button, we leave 'onClick' undefined\n *         // rather than specifying a NotificationActionResult. This means that no action will be raised when the\n *         // button is clicked, and hence no \"notification-action\" event will be fired\n *         {\n *             title: 'Dismiss',\n *             iconUrl: 'https://www.example.com/cancel.png'\n *         }\n *     ]\n * });\n *\n * // Create a listener that will be called for each action\n * // Note: This handler will be used for ALL actions, from ALL notifications that are created by this application.\n * addEventListener('notification-action', (event: NotificationActionEvent) => {\n *     const {result, notification} = event;\n *\n *     if (result['task'] === 'view-calendar-event') {\n *         // Open a window with full details of the associated event\n *         openEventDetails(notification.customData.eventId, result['target']);\n *     } else if (result['task'] === 'schedule-reminder') {\n *         // Schedule a new notification\n *         scheduleReminder(notification.customData.eventId, Date.now() + result['intervalMs']);\n *     } // Etc...\n * });\n * ```\n *\n * The example above uses `customData` to store details about the notification subject (in this case, a calendar\n * event), and `onClick` actions to inform the application about how it should respond when the user interacts with the\n * notification. This is our intended usage and recommended best-practice, but the service doesn't require applications\n * to follow this convention - application developers are free to decide how to manage notification state.\n *\n * Within the `notification-action` handler, the application must be able to understand which notification is being\n * handled, and how to decide what it should do next. The example above uses an application-defined `action` field to\n * determine the correct action, but the notification's `id`, `category`, `customData` and other fields are also useful\n * selectors.\n *\n * @module Actions\n */\n\n/**\n * Need a comment block here so that the comment block above is interpreted as a file comment, and not a comment on the\n * import below.\n *\n * @hidden\n */\nimport { CustomData } from '.';\n\n/**\n * Denotes a field as being an action. Defining this field (with a non-`undefined` value) will result in actions being\n * raised and sent back to the source application when the corresponding event happens.\n *\n * For example, providing a value for the `onClick` field of {@link ButtonOptions} will result in a\n * {@link NotificationActionEvent|`notification-action`} event being fired when that button is clicked.\n *\n * In the current version of the service, the `NotificationActionResult`s returned back to an application are static\n * and must bedefined at the point where the notification is created. Later versions of the service will allow some\n * limited programmatic creation of these results, for use in situations where static result data isn't sufficient.\n *\n * The generic parameters of this type are for future expansion. Future versions of the service will allow for more\n * control over the handling of actions.\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport type ActionDeclaration<T extends never, E extends never> = NotificationActionResult;\n\n/**\n * Data type used to represent the action result returned back to applications when an action is raised. Applications\n * capture these responses by adding a `notification-action` listener. The contents of this type are entirely\n * application-defined, the only requirement is that the item is serializable by `JSON.stringify`.\n *\n * Since this type is entirely application-specific, the type  is used in these definitions. However, there is an\n * optional generic argument here, which can be used if an application were to define its own conventions for the shape\n * of this field (which is recommended). To make use of this, define a `notification-action` handler that includes the\n * application-defined type as a template argument. This type is then propogated up to {@link NotificationActionEvent}.\n * The example below demonstrates this, using the same use-case as at the top of this page.\n *\n * ```ts\n * interface MyAction = SnoozeAction | DetailsAction;\n *\n * interface SnoozeAction {\n *     task: 'schedule-reminder';\n *     intervalMs: number;\n * }\n *\n * interface DetailsAction {\n *     task: 'view-calendar-event';\n *     target: 'self'|'popup';\n * }\n *\n * addEventListener('notification-action', (event: NotificationActionEvent<MyAction>)) => {\n *     if (event.result.task === 'schedule-reminder') {\n *         // 'event.result' will now be strongly-typed as an instance of SnoozeAction\n *         scheduleReminder(notification.customData.eventId, Date.now() + result.intervalMs);\n *     }\n *     // Etc...\n * });\n * ```\n */\nexport type NotificationActionResult<T = CustomData> = T;\n\n/**\n * Lists the different triggers that can raise an {@link Actions|action}. Each action that is raised will result in a\n * {@link NotificationActionEvent|`notification-action`} event, which can be captured by the application that created\n * the notification.\n */\nexport enum ActionTrigger {\n  /**\n   * The user interacted with one of the controls within the notification. This currently means a button click, but\n   * other control types will be added in future releases.\n   */\n  CONTROL = 'control',\n\n  /**\n   * The user clicked the body of the notification itself. Any clicks of the notification that don't hit a control\n   * or the close button will fire an event with the `'select'` action trigger.\n   */\n  SELECT = 'select',\n\n  /**\n   * The notification was closed, either by user interaction, programmatically by an application, or by the notification expiring.\n   */\n  CLOSE = 'close',\n\n  /**\n   * The notification expired.\n   */\n  EXPIRE = 'expire',\n\n  /**\n   * The action was triggered programmatically by an application.\n   *\n   * *Not currently supported - will be implemented in a future release*\n   */\n  PROGRAMMATIC = 'programmatic',\n}\n\n/**\n * Noop action types see {@link ActionNoop|ActionNoop}.\n */\nexport enum ActionNoopType {\n  /**\n   * No event will be raised and no dismissal of the notification on action.\n   */\n  EVENT_DISMISS = 'event_dismiss',\n  /**\n   * No event will be raised, but the notification will be dismissed on action.\n   */\n  // EVENT = 'event',\n  /**\n   * No dismissal of the notification, but the action event will be raised on action.\n   */\n  // DISMISS = 'dismiss',\n}\n\n/**\n * Setting the `__NOOP__` field on an action with a {@link ActionNoopType|type} allows you to override default user interaction with a notification.\n *\n * For example, creating a notification:\n * ```\n * const notification = {\n *  //...\n *  onSelect: {__NOOP__: ActionNoopType.EVENT_DISMISS}\n * };\n * ```\n * When a user clicks the notification body, the notification will not be dismissed and no event will be raised to the client application.\n *\n * **Currently `ActionNoopType.EVENT_DISMISS` is only supported by `ActionTrigger.SELECT`/`onSelect`.**\n */\nexport interface ActionNoop {\n  __NOOP__?: ActionNoopType;\n}\n","/**\n * @hidden\n */\n\n/**\n * File contains vars used to establish service connection between client and provider.\n *\n * These are separated out from 'internal.ts' as including these from provider code will cause the provider to connect\n * to itself.\n *\n * These types are a part of the client, but are not required by applications wishing to interact with the service.\n * This file is excluded from the public-facing TypeScript documentation.\n */\nimport { EventEmitter } from 'events';\n\nimport { ChannelClient } from 'openfin/_v2/api/interappbus/channel/client';\nimport { DeferredPromise } from 'openfin-service-async';\n\nimport { APITopic, SERVICE_CHANNEL, API, SERVICE_IDENTITY, Events } from './internal';\nimport { EventRouter, Targeted, Transport } from './EventRouter';\n\n/**\n * The version of the NPM package.\n *\n * Webpack replaces any instances of this constant with a hard-coded string at build time.\n */\ndeclare const PACKAGE_VERSION: string;\n\n/**\n * The event emitter to emit events received from the service.  All addEventListeners will tap into this.\n */\nexport const eventEmitter = new EventEmitter();\n\n/**\n * Promise to the channel object that allows us to connect to the client\n */\nlet channelPromise: Promise<ChannelClient> | null;\nconst hasDOMContentLoaded = new DeferredPromise<void>();\nlet reconnect = false;\n\nconst MIN_API_VERSION = 53;\n\nif (typeof fin !== 'undefined') {\n  launchSystemApp();\n  getServicePromise();\n  if (document.readyState !== 'loading') {\n    hasDOMContentLoaded.resolve();\n  } else {\n    window.addEventListener('DOMContentLoaded', () => {\n      hasDOMContentLoaded.resolve();\n    });\n    document.addEventListener('DOMContentLoaded', () => {\n      hasDOMContentLoaded.resolve();\n    });\n  }\n}\n\nasync function launchSystemApp() {\n  if (!window.navigator.appVersion.includes('Windows')) {\n    // Mac has an RVM now\n    fin.System.openUrlWithBrowser('fins://system-apps/notification-center');\n    return;\n  }\n  try {\n    const info = await fin.System.getRvmInfo();\n    const major = parseInt(info.version.split('.')[0]);\n    if (major >= 6) {\n      // @ts-ignore\n      if (fin.System.launchManifest) {\n        // Launch with no ui in newer runtimes that support the `launchManifest` api.\n        // @ts-ignore\n        fin.System.launchManifest('fins://system-apps/notification-center', { noUi: true }).catch(\n          (error: Error) => {\n            console.error('Unable to launch the Notification Center as a system app', error);\n          }\n        );\n      } else {\n        // Fallback to launching with ui\n        fin.System.openUrlWithBrowser('fins://system-apps/notification-center').catch(() => {});\n      }\n    }\n  } catch (e) {\n    // Do nothing\n  }\n}\n\nexport async function getServicePromise(): Promise<ChannelClient> {\n  await hasDOMContentLoaded.promise;\n  if (!channelPromise) {\n    if (typeof fin === 'undefined') {\n      const msg =\n        'fin is not defined. The openfin-notifications module is only intended for use in an OpenFin application.';\n      channelPromise = Promise.reject(new Error(msg));\n      return channelPromise;\n    }\n\n    // You can't use an `await` here. If you do, you introduce a race condition that makes this function non-reentrant, and you end\n    // up with multiple connections to the provider. So don't do that.\n    fin.System.getVersion().then((v) => {\n      const apiVersion = parseInt(v.split('.')[2]);\n      if (apiVersion < MIN_API_VERSION) {\n        console.warn(\n          `API version ${apiVersion} of OpenFin version ${v} is less than ${MIN_API_VERSION}. Please upgrade the runtime version.`\n        );\n      }\n    });\n\n    // @ts-ignore fin.me has no types yet\n    const { name, uuid } = fin.me?.identity ?? fin.Window.me;\n    if (uuid === SERVICE_IDENTITY.uuid && name === SERVICE_IDENTITY.name) {\n      // Currently a runtime bug when provider connects to itself. Ideally the provider would never import a file\n      // that includes this, but for now it is easier to put a guard in place.\n      channelPromise = Promise.reject(new Error('Trying to connect to provider from provider'));\n    } else {\n      const timeoutHandle = window.setTimeout(() => {\n        console.warn(\n          'Taking a long time to connect to Notifications service. Is the Notifications service running?'\n        );\n      }, 5000);\n\n      channelPromise = fin.InterApplicationBus.Channel.connect(SERVICE_CHANNEL, {\n        wait: true,\n        payload: { version: PACKAGE_VERSION },\n      }).then((channel: ChannelClient) => {\n        window.clearTimeout(timeoutHandle);\n\n        const eventRouter = getEventRouter();\n\n        // Register service listeners\n        channel.register('WARN', (payload: unknown) => console.warn(payload));\n        channel.register('event', (event: Targeted<Transport<Events>>) => {\n          eventRouter.dispatchEvent(event);\n        });\n        // Any unregistered action will simply return false\n        channel.setDefaultAction(() => false);\n\n        channel.onDisconnection(() => {\n          console.warn('Disconnected from Notifications service');\n          reconnect = true;\n          channelPromise = null;\n          // Relaunch notifications incase it was launched as a service first\n          launchSystemApp();\n          setTimeout(() => {\n            console.log('Attempting to reconnect to Notifications service');\n            getServicePromise();\n          }, 300);\n        });\n\n        if (reconnect) {\n          console.log('Reconnected to Notifications service');\n        } else {\n          console.log('Connected to Notifications service');\n        }\n\n        return channel;\n      });\n    }\n  }\n\n  return channelPromise;\n}\n\n/**\n * Wrapper around service.dispatch to help with type checking\n * @param action Action type.\n * @param payload Data payload to send to the provider.\n */\nexport async function tryServiceDispatch<T extends APITopic>(\n  action: T,\n  payload: API[T][0]\n): Promise<API[T][1]> {\n  const channel: ChannelClient = await getServicePromise();\n  return channel.dispatch(action, payload) as Promise<API[T][1]>;\n}\n\nlet eventRouter: EventRouter<Events> | null;\n\nexport function getEventRouter(): EventRouter<Events> {\n  if (!eventRouter) {\n    eventRouter = new EventRouter(eventEmitter);\n  }\n\n  return eventRouter;\n}\n","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./async\"));\n__export(require(\"./DeferredPromise\"));\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass DeferredPromise {\n    constructor() {\n        const promise = new Promise((res, rej) => {\n            this._resolve = res;\n            this._reject = rej;\n        });\n        this._promise = promise;\n    }\n    get promise() {\n        return this._promise;\n    }\n    get resolve() {\n        return this._resolve;\n    }\n    get reject() {\n        return this._reject;\n    }\n}\nexports.DeferredPromise = DeferredPromise;\n","/**\n * These are the templates you can use.\n *\n * @module Templates\n */\n\n/**\n * imports\n */\nimport { NotificationFormData } from '../forms/fields';\n\nimport { BaseNotificationOptions } from './BaseNotificationOptions';\n\n/**\n * The options you pass to the [[create]] function to generate a notification.\n */\nexport type NotificationOptions = TemplateMarkdown | TemplateList;\n\nexport const TemplateNames = {\n  markdown: 'markdown',\n  list: 'list',\n} as const;\n\n/**\n * Default markdown template. Contains a markdown body and forms data.\n */\nexport interface TemplateMarkdown extends Omit<BaseNotificationOptions<'markdown'>, 'template'> {\n  template?: 'markdown';\n  /**\n   * Notification body text.\n   *\n   * This is the main notification content, displayed below the notification title. The notification will expand to fit the length of this text.\n   * Markdown may be used in the body text to control how it is styled when rendered.\n   * With the exception of links and code blocks, all basic syntax as documented [here](https://www.markdownguide.org/basic-syntax) is supported.\n   */\n  body: string;\n\n  form?: NotificationFormData | null;\n}\n\n/**\n * Simple template that can render a list of name-value pairs.\n */\nexport interface TemplateList extends BaseNotificationOptions<'list'> {\n  /**\n   * Notification list template data.\n   */\n  list: Record<string, string>;\n}\n","/* eslint-disable no-redeclare */\n/**\n * @module NotificationCenter\n */\n\n/**\n * Need a comment block here so that the comment block above is interpreted as a file comment, and not a comment on the\n * import below.\n *\n * @hidden\n */\nimport { NotificationActionResult, ActionTrigger } from './actions';\nimport { tryServiceDispatch, eventEmitter, getEventRouter } from './connection';\nimport { ButtonOptions, ControlOptions } from './controls';\nimport {\n  APITopic,\n  CreatePayload,\n  DistributiveOmit,\n  Events,\n  NotificationInternal,\n} from './internal';\nimport { EventRouter, Transport } from './EventRouter';\nimport * as provider from './provider';\nimport { NotificationSource } from './source';\nimport { validateEnvironment, sanitizeEventType, sanitizeFunction } from './validation';\nimport { NotificationIndicator, IndicatorType } from './indicator';\nimport { NotificationOptions } from './templates/templates';\n\nexport * from './actions';\nexport * from './controls';\nexport * from './source';\nexport * from './forms';\nexport * from './stream';\nexport * from './templates';\n\nexport { provider, NotificationOptions };\nexport { NotificationIndicator, IndicatorType as NotificationIndicatorType };\n\n/**\n * The version of the NPM package.\n *\n * Webpack replaces any instances of this constant with a hard-coded string at build time.\n */\ndeclare const PACKAGE_VERSION: string;\n\n/**\n * The Notification Client library's version in semver format.\n *\n * This is the version which you are currently using.\n */\nexport const VERSION = PACKAGE_VERSION;\n\nconst eventHandler: EventRouter<Events> = getEventRouter();\n\nfunction parseEventWithNotification<T extends { notification: NotificationInternal }>(\n  event: T\n): T & { notification: Notification } {\n  const { notification } = event;\n\n  return {\n    ...event,\n    notification: {\n      ...notification,\n      date: new Date(notification.date),\n      expires: notification.expires !== null ? new Date(notification.expires) : null,\n    } as Notification,\n  };\n}\n\neventHandler.registerDeserializer<NotificationCreatedEvent>(\n  'notification-created',\n  (event: Transport<NotificationCreatedEvent>) => {\n    return parseEventWithNotification(event);\n  }\n);\neventHandler.registerDeserializer<NotificationClosedEvent>(\n  'notification-closed',\n  (event: Transport<NotificationClosedEvent>) => {\n    return parseEventWithNotification(event);\n  }\n);\neventHandler.registerDeserializer<NotificationActionEvent>(\n  'notification-action',\n  (event: Transport<NotificationActionEvent>) => {\n    const { controlSource, controlIndex, ...rest } = parseEventWithNotification(event);\n\n    if (event.trigger === ActionTrigger.CONTROL) {\n      const control = event.notification[controlSource!][controlIndex!];\n      return { ...rest, control };\n    } else {\n      return rest;\n    }\n  }\n);\n\neventHandler.registerDeserializer<NotificationsCountChanged>(\n  'notifications-count-changed',\n  (event: Transport<NotificationsCountChanged>) => {\n    return event;\n  }\n);\n\n/**\n * Application-defined context data that can be attached to buttons on notifications.\n */\nexport type CustomData = Record<string, any>;\n\n/**\n * A fully-hydrated form of {@link NotificationOptions}.\n *\n * After {@link create|creating} a notification, the service will return an object of this type. This will be the given\n * options object, with any unspecified fields filled-in with default values.\n *\n * This object should be treated as immutable. Modifying its state will not have any effect on the notification or the\n * state of the service.\n */\nexport type Notification<T extends NotificationOptions = NotificationOptions> = Readonly<\n  Required<DistributiveOmit<T, 'buttons'>> & {\n    readonly buttons: ReadonlyArray<Required<ButtonOptions>>;\n  }\n>;\n\n/**\n * Event fired when an action is raised for a notification due to a specified trigger. It is important to note that\n * applications will only receive these events if they indicate to the service that they want to receive these events.\n * See {@link Actions} for a full example of how actions are defined, and how an application can listen to and handle\n * them.\n *\n * This can be fired due to interaction with notification buttons or the notification itself, the notification being\n * closed (either by user interaction or by API call), or by the notification expiring. Later versions of the service\n * will add additional control types that may raise actions from user interaction. All actions, for all control types,\n * will be returned to the application via the same `notification-action` event type.\n *\n * The event object will contain the application-defined {@link NotificationActionResult|metadata} that allowed this\n * action to be raised, and details on what triggered this action and which control the user interacted with.\n *\n * Unlike other event types, `notification-action` events will be buffered by the service until the application has\n * added a listener for this event type, at which point it will receive all buffered `notification-action` events. The\n * service will also attempt to restart the application if it is not running when the event is fired.\n *\n * This type includes a generic type argument, should applications wish to define their own interface for action\n * results. See {@link NotificationActionResult} for details.\n *\n * @event \"notification-action\"\n */\nexport interface NotificationActionEvent<T = CustomData> {\n  type: 'notification-action';\n\n  /**\n   * The notification that created this action\n   */\n  notification: Readonly<Notification>;\n\n  /**\n   * This property allows the application handling the action to identify where this notification originated.\n   */\n  source: NotificationSource;\n\n  /**\n   * Indicates what triggered this action.\n   *\n   * Note that the `programmatic` trigger is not yet implemented.\n   */\n  trigger: ActionTrigger;\n\n  /**\n   * The control whose interaction resulted in this action being raised. Will only be present when {@link trigger} is\n   * {@link ActionTrigger.CONTROL}.\n   *\n   * Future versions of the service will add additional controls beyond buttons, and interactions with these new\n   * control types will also come through this one event type. For best forward-compatibility, applications should\n   * always check the `type` property of this control, and not assume that the type will always be `'button'`.\n   *\n   * This field is marked optional as future versions of the service will also include alternate methods of raising\n   * `notification-action` events that do not originate from a button or other control.\n   *\n   * When present, the object here will always be strictly equal to one of the control definitions within\n   * `notification`. This means `indexOf` checks and other equality checks can be performed on this field if\n   * required, such as:\n   *\n   * ```ts\n   * function onNotificationAction(event: NotificationActionEvent): void {\n   *     if (event.control && event.control.type === 'button') {\n   *         const butttonIndex = event.notification.buttons.indexOf(event.control);\n   *\n   *         // Handle button click\n   *         // . . .\n   *     }\n   * }\n   * ```\n   */\n  control?: Readonly<Required<ControlOptions>>;\n\n  /**\n   * Application-defined metadata that this event is passing back to the application.\n   *\n   * A `notification-action` event is only fired for a given trigger if the\n   * {@link NotificationOptions|notification options} included an action result for that trigger.\n   *\n   * See the comment on the {@link NotificationActionEvent} type for an example of buttons that do and don't raise\n   * actions.\n   */\n  result: NotificationActionResult<T>;\n}\n\n/**\n * Event fired whenever the notification has been closed.\n *\n * This event is fired regardless of how the notification was closed - i.e.: via a call to `clear`/`clearAll`, the\n * notification expiring, or by a user clicking either the notification itself, the notification's close button, or\n * a button on the notification.\n *\n * @event \"notification-closed\"\n */\nexport interface NotificationClosedEvent {\n  type: 'notification-closed';\n\n  /**\n   * The notification that has just been closed.\n   *\n   * This object will match what is returned from the `create` call when the notification was first created.\n   */\n  notification: Notification;\n}\n\n/**\n * Event fired whenever a new notification has been created.\n *\n * @event \"notification-created\"\n */\nexport interface NotificationCreatedEvent {\n  type: 'notification-created';\n\n  /**\n   * The notification that has just been created.\n   *\n   * This object will match what is returned from the `create` call.\n   */\n  notification: Notification;\n}\n\n/**\n * Event fired whenever the total number of notifications from **all** sources changes.\n *\n * @event \"notifications-count-changed\"\n */\nexport interface NotificationsCountChanged {\n  type: 'notifications-count-changed';\n  /**\n   * Number of notifications in the Center.\n   */\n  count: number;\n}\n\nexport interface NotificationFormSubmittedEvent {\n  type: 'notification-form-submitted';\n  notification: Notification;\n  form: Record<string, unknown>;\n}\n\nexport function addEventListener(\n  eventType: 'notification-form-submitted',\n  listener: (event: NotificationFormSubmittedEvent) => void\n): void;\nexport function addEventListener(\n  eventType: 'notification-action',\n  listener: (event: NotificationActionEvent) => void\n): void;\nexport function addEventListener(\n  eventType: 'notification-created',\n  listener: (event: NotificationCreatedEvent) => void\n): void;\nexport function addEventListener(\n  eventType: 'notification-closed',\n  listener: (event: NotificationClosedEvent) => void\n): void;\nexport function addEventListener(\n  eventType: 'notifications-count-changed',\n  listener: (event: NotificationsCountChanged) => void\n): void;\n\n/**\n * Adds a listener, see definitions of individual event interfaces for details on each event.\n *\n * @param eventType The event being subscribed to\n * @param listener The callback function to add\n */\nexport function addEventListener<E extends Events>(\n  eventType: E['type'],\n  listener: (event: E) => void\n): void {\n  validateEnvironment();\n  eventType = sanitizeEventType(eventType);\n  listener = sanitizeFunction(listener);\n\n  const count = eventEmitter.listenerCount(eventType);\n  eventEmitter.addListener(eventType, listener);\n  if (count === 0 && eventEmitter.listenerCount(eventType) === 1) {\n    tryServiceDispatch(APITopic.ADD_EVENT_LISTENER, eventType);\n  }\n}\n\nexport function removeEventListener(\n  eventType: 'notification-form-submitted',\n  listener: (event: NotificationFormSubmittedEvent) => void\n): void;\nexport function removeEventListener(\n  eventType: 'notification-action',\n  listener: (event: NotificationActionEvent) => void\n): void;\nexport function removeEventListener(\n  eventType: 'notification-created',\n  listener: (event: NotificationCreatedEvent) => void\n): void;\nexport function removeEventListener(\n  eventType: 'notification-closed',\n  listener: (event: NotificationClosedEvent) => void\n): void;\nexport function removeEventListener(\n  eventType: 'notifications-count-changed',\n  listener: (event: NotificationsCountChanged) => void\n): void;\n\n/**\n * Removes a listener previously added with {@link addEventListener}.\n *\n * Has no effect if `listener` isn't a callback registered against `eventType`.\n *\n * @param eventType The event being unsubscribed from\n * @param listener The callback function to remove, must be strictly-equal (`===` equivilance) to a listener previously passed to {@link addEventListener} to have an effect\n */\nexport function removeEventListener<E extends Events>(\n  eventType: E['type'],\n  listener: (event: E) => void\n): void {\n  validateEnvironment();\n  eventType = sanitizeEventType(eventType);\n  listener = sanitizeFunction(listener);\n\n  const count = eventEmitter.listenerCount(eventType);\n  eventEmitter.removeListener(eventType, listener);\n  if (count === 1 && eventEmitter.listenerCount(eventType) === 0) {\n    tryServiceDispatch(APITopic.REMOVE_EVENT_LISTENER, eventType);\n  }\n}\n\n/**\n * Creates a new notification.\n *\n * The notification will appear in the Notification Center and as a toast if the Center is not visible.\n *\n * If a notification is created with an `id` of an already existing notification, the existing notification will be recreated with the new content.\n *\n * ```ts\n * import {create} from 'openfin-notifications';\n *\n * create({\n *      id: 'uniqueNotificationId',\n *      title: 'Notification Title',\n *      body: 'Text to display within the notification body',\n *      category: 'Sample Notifications',\n *      icon: 'https://openfin.co/favicon.ico'\n * });\n * ```\n *\n * @param options Notification configuration options.\n */\nexport async function create<T extends NotificationOptions>(options: T): Promise<Notification<T>> {\n  // Most validation logic is handled on the provider, but need an early check here\n  // as we call date.valueOf when converting into a CreatePayload\n  if (typeof options !== 'object' || options === null) {\n    throw new Error(\n      'Invalid argument passed to create: argument must be an object and must not be null'\n    );\n  }\n\n  if (options.date !== undefined && !(options.date instanceof Date)) {\n    throw new Error('Invalid argument passed to create: \"date\" must be a valid Date object');\n  }\n\n  if (\n    options.expires !== undefined &&\n    options.expires !== null &&\n    !(options.expires instanceof Date)\n  ) {\n    throw new Error(\n      'Invalid argument passed to create: \"expires\" must be null or a valid Date object'\n    );\n  }\n\n  const response = await tryServiceDispatch(APITopic.CREATE_NOTIFICATION, {\n    ...options,\n    date: options.date && options.date.valueOf(),\n    expires: options.expires && options.expires.valueOf(),\n  } as CreatePayload);\n  return ({\n    ...response,\n    date: new Date(response.date),\n    expires: response.expires !== null ? new Date(response.expires) : null,\n  } as unknown) as Notification<T>;\n}\n\n/**\n * Clears a specific notification from the Notification Center.\n *\n * Returns true if the notification was successfully cleared.  Returns false if the notification was not cleared, without errors.\n *\n * ```ts\n * import {clear} from 'openfin-notifications';\n *\n * clear('uniqueNotificationId');\n * ```\n *\n * @param id ID of the notification to clear.\n */\nexport async function clear(id: string): Promise<boolean> {\n  // Should have some sort of input validation here...\n  return tryServiceDispatch(APITopic.CLEAR_NOTIFICATION, { id });\n}\n\n/**\n * Retrieves all Notifications which were created by the calling application, including child windows.\n *\n * ```ts\n * import {getAll} from 'openfin-notifications'\n *\n * getAll().then((notifications: Notification[]) => {\n *     console.log(`Service has ${notifications.length} notifications for this app:`, notifications);\n * });\n * ```\n *\n * There is deliberately no mechanism provided for fetching notifications that were created by a different application.\n */\nexport async function getAll(): Promise<Notification[]> {\n  // Should have some sort of input validation here...\n  const response = await tryServiceDispatch(APITopic.GET_APP_NOTIFICATIONS, undefined);\n  return response.map((note) => {\n    return {\n      ...note,\n      indicator: note.indicator || null,\n      date: new Date(note.date),\n      expires: note.expires !== null ? new Date(note.expires) : null,\n    };\n  });\n}\n\n/**\n * Clears all Notifications which were created by the calling application, including child windows.\n *\n * Returns the number of successfully cleared Notifications.\n *\n * ```ts\n * import {clearAll} from 'openfin-notifications';\n *\n * clearAll();\n * ```\n */\nexport async function clearAll(): Promise<number> {\n  // Should have some sort of input validation here...\n  return tryServiceDispatch(APITopic.CLEAR_APP_NOTIFICATIONS, undefined);\n}\n\n/**\n * Toggles the visibility of the Notification Center.\n *\n * ```ts\n * import {toggleNotificationCenter} from 'openfin-notifications';\n *\n * toggleNotificationCenter();\n * ```\n */\nexport async function toggleNotificationCenter(): Promise<void> {\n  return tryServiceDispatch(APITopic.TOGGLE_NOTIFICATION_CENTER, undefined);\n}\n\n/**\n * Get the total count of notifications from **all** applications.\n *\n * ```ts\n * import {getNotificationsCount} from 'openfin-notifications';\n *\n * getNotificationsCount();\n * ```\n */\nexport async function getNotificationsCount(): Promise<number> {\n  return tryServiceDispatch(APITopic.GET_NOTIFICATIONS_COUNT, undefined);\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst DeferredPromise_1 = require(\"./DeferredPromise\");\nasync function serialForEach(arr, asyncF) {\n    let i = 0;\n    for (const x of arr) {\n        await asyncF(x, i, arr);\n        i++;\n    }\n}\nexports.serialForEach = serialForEach;\nasync function serialMap(arr, asyncF) {\n    const result = [];\n    await serialForEach(arr, async (x, i, r) => {\n        result.push(await asyncF(x, i, r));\n    });\n    return result;\n}\nexports.serialMap = serialMap;\nasync function serialFilter(arr, asyncF) {\n    const result = [];\n    await serialForEach(arr, async (x, i, r) => {\n        if (await asyncF(x, i, r)) {\n            result.push(x);\n        }\n    });\n    return result;\n}\nexports.serialFilter = serialFilter;\nasync function parallelForEach(arr, asyncF) {\n    await Promise.all(arr.map(asyncF));\n}\nexports.parallelForEach = parallelForEach;\nasync function parallelMap(arr, asyncF) {\n    const result = [];\n    await parallelForEach(arr, async (x, i, r) => {\n        result[i] = await asyncF(x, i, r);\n    });\n    return result;\n}\nexports.parallelMap = parallelMap;\nasync function parallelFilter(arr, asyncF) {\n    const table = [];\n    await parallelForEach(arr, async (x, i, r) => {\n        table[i] = await asyncF(x, i, r);\n    });\n    return arr.filter((x, i) => table[i]);\n}\nexports.parallelFilter = parallelFilter;\n/**\n * Races a given promise against a timeout, and either resolves to the value the the promise resolved it, if it resolved before the\n * timeout, or rejects.\n *\n * @param timeoutMs Timeout period in ms\n * @param promise Promise to race against the timeout\n */\nfunction withStrictTimeout(timeoutMs, promise, rejectMessage) {\n    const timeout = new Promise((res, rej) => setTimeout(() => rej(new Error(rejectMessage)), timeoutMs));\n    return allowReject(Promise.race([timeout, promise]));\n}\nexports.withStrictTimeout = withStrictTimeout;\n/**\n * Races a given promise against a timeout, and resolves to a `[didTimeout, value?]` tuple indicating\n * whether the timeout occurred, and the value the promise resolved to (if timeout didn't occur).\n *\n * @param timeoutMs Timeout period in ms\n * @param promise Promise to race against the timeout\n */\nfunction withTimeout(timeoutMs, promise) {\n    const timeout = new Promise((res) => setTimeout(() => res([true, undefined]), timeoutMs));\n    const p = promise.then((value) => [false, value]);\n    return Promise.race([timeout, p]);\n}\nexports.withTimeout = withTimeout;\n/**\n * Returns a promise that resolves when the given predicate is true, evaluated immediately and each time the provided signal is fired.\n *\n * @param signal When this signal is fired, the predicate is revaluated\n * @param predicate The predicate to evaluate\n * @param guard A promise. If this rejects, give up listening to the signal and reject\n */\nfunction untilTrue(signal, predicate, guard) {\n    if (predicate()) {\n        return Promise.resolve();\n    }\n    return untilSignal(signal, predicate, guard);\n}\nexports.untilTrue = untilTrue;\n/**\n * Returns a promise that resolves when the given signal is fired, and the given predicate evaluates to true when passed the arguments\n * recevied from the signal.\n *\n * @param signal The signal to listen to\n * @param predicate The predicate to evaluate against arguments received from the signal\n * @param guard A promise. If this rejects, give up listening to the signal and reject\n */\nfunction untilSignal(signal, predicate, guard) {\n    const promise = new DeferredPromise_1.DeferredPromise();\n    const slot = signal.add((...args) => {\n        if (predicate(...args)) {\n            slot.remove();\n            promise.resolve();\n        }\n    });\n    if (guard) {\n        guard.catch((e) => {\n            slot.remove();\n            promise.reject(e);\n        });\n    }\n    return allowReject(promise.promise);\n}\nexports.untilSignal = untilSignal;\n/**\n * Attaches an empty `catch` block to a promise, then returns the original promise. This prevents rejection of the promise being logged as\n * a warning during tests, but does not otherwise change behaviour should the promise reject. This should be called for promises we expect\n * to reject under normal circumstances, but would not otherwise have a `catch` block attached.\n *\n * @param promise The promise to attach the catch block to\n */\nfunction allowReject(promise) {\n    promise.catch(() => { });\n    return promise;\n}\nexports.allowReject = allowReject;\n","/**\n * @hidden\n */\n\n/**\n * Acts as a central point for routing all events received from the provider.\n */\nimport { EventEmitter } from 'events';\n\nimport { TransportMappings, TransportMemberMappings } from './internal';\n\nexport interface EventSpecification {\n  type: string;\n}\n\ntype EmitterProvider = (targetId: string) => EventEmitter;\ntype EventDeserializer<E extends EventSpecification, T extends E> = (event: Transport<T>) => T;\n\ninterface EventTarget {\n  type: string;\n  id: string;\n}\nexport type Targeted<T extends EventSpecification> = T & {\n  /**\n   * Indicates which emitter the client should use to dispatch this event.\n   *\n   * Allows events to be raised from client-side objects that mirror a corresponding provider-side object. If there\n   * is no such model of client-side objects, pass `default` to emit the event from a shared top-level/\"global\" event\n   * emitter.\n   */\n  target: EventTarget | 'default';\n};\nexport type Transport<T extends EventSpecification> = TransportMappings<T> extends never\n  ? {\n      [K in keyof T]: TransportMemberMappings<T[K]>;\n    }\n  : TransportMappings<T>;\n\n/**\n * Class for helping take events that have arrived at the client via the IAB channel, and dispatching them on the correct client-side object\n */\nexport class EventRouter<E extends EventSpecification> {\n  private readonly _emitterProviders: { [targetType: string]: (targetId: string) => EventEmitter };\n  private readonly _deserializers: { [eventType: string]: EventDeserializer<E, E> };\n\n  private readonly _defaultEmitter: EventEmitter;\n\n  public constructor(defaultEmitter: EventEmitter) {\n    this._emitterProviders = {};\n    this._deserializers = {};\n\n    this._defaultEmitter = defaultEmitter;\n  }\n\n  public registerEmitterProvider(targetType: string, emitterProvider: EmitterProvider): void {\n    this._emitterProviders[targetType] = emitterProvider;\n  }\n\n  public registerDeserializer<T extends E>(\n    eventType: T['type'],\n    deserializer: EventDeserializer<E, T>\n  ): void {\n    this._deserializers[eventType] = (deserializer as unknown) as EventDeserializer<E, E>;\n  }\n\n  public dispatchEvent<T extends E>(event: Targeted<Transport<T>>): void {\n    const { type, target, ...rest } = event;\n\n    let emitter: EventEmitter;\n    if (!target) {\n      throw new Error('Invalid event, no target specified');\n    } else if (target === 'default') {\n      emitter = this._defaultEmitter;\n    } else if (this._emitterProviders[target.type]) {\n      emitter = this._emitterProviders[target.type](target.id);\n    } else {\n      throw new Error(`Invalid target, no provider registered for '${target.type}'`);\n    }\n\n    // Need to remove 'target' from event before emitting event\n    const inputEvent: Transport<T> = ({ type, ...rest } as unknown) as Transport<T>;\n\n    // Also run through any custom deserializer\n    const deserializer = this._deserializers[type];\n    if (deserializer) {\n      emitter.emit(type, deserializer(inputEvent));\n    } else {\n      emitter.emit(type, inputEvent);\n    }\n  }\n}\n","/**\n * @module Provider\n */\n\n/**\n * Need a comment block here so that the comment block above is interpreted as a file comment, and not a comment on the\n * import below.\n *\n * @hidden\n */\nimport semverCompare from 'semver-compare';\nimport { withStrictTimeout } from 'openfin-service-async';\n\nimport { tryServiceDispatch } from './connection';\nimport { APITopic } from './internal';\n\n/**\n * Status object returned by the Provider.\n */\nexport interface ProviderStatus {\n  /**\n   * The current connection status from the Client to the Provider.\n   */\n  connected: boolean;\n\n  /**\n   * The version number of the Provider. If the Provider is not connected, this will be `null`.\n   */\n  version: string | null;\n}\n\n/**\n * Retrieves the connection status and version semver of the Service Provider in the shape of a {@link ProviderStatus} object.\n *\n * If the Provider is connected, its' version number will be supplied in the returned object. If not, `version` will be `null`.\n *\n * ```ts\n * import {provider} from 'openfin-notifications';\n *\n * const status: ProviderStatus = provider.getStatus();\n * console.log(status.connected ? `Conencted to provider (version ${status.version})` : 'Not connected to provider');\n * ```\n *\n * Note: Connection status is only available when the connected provider is verison 0.11.2 or later. For earlier\n * versions, this API will indicate that the provider is disconnected.\n *\n * @since 0.11.2\n */\nexport function getStatus(): Promise<ProviderStatus> {\n  // We need to race a timeout here as we never reject if the provider is not connected.\n  return withStrictTimeout(\n    500,\n    tryServiceDispatch(APITopic.GET_PROVIDER_STATUS, undefined),\n    ''\n  ).catch(() => {\n    return {\n      connected: false,\n      version: null,\n    };\n  });\n}\n\n/**\n * Evaluates the provided version against the Providers version.\n *\n * This will return `true` if the Provider version is greater than or equal to the provided version. If not, `false` will be returned.\n *\n * If the Provider is not connected, `false` will be returned.\n *\n * ```ts\n * import {provider, VERSION} from 'openfin-notifications';\n *\n * const hasMatchingProvider: boolean = provider.isConnectedToAtLeast(VERSION);\n * if (!hasMatchingProvider) {\n *     console.warn('Connected to an older provider version. Some functionality may not be available.');\n * }\n * ```\n *\n * Note: Version information is only available when the connected provider is verison 0.11.2 or later. For earlier\n * versions, this API will indicate that the provider is disconnected.\n *\n * @param version Version to compare against the Provider version. This should be in semvar format.\n * @since 0.11.2\n */\nexport async function isConnectedToAtLeast(version: string): Promise<boolean> {\n  const status = await getStatus();\n\n  if (status.connected && status.version !== null) {\n    const compare = semverCompare(status.version, version);\n\n    if (compare === 0 || compare === 1) {\n      return true;\n    }\n  }\n\n  return false;\n}\n","module.exports = function cmp (a, b) {\n    var pa = a.split('.');\n    var pb = b.split('.');\n    for (var i = 0; i < 3; i++) {\n        var na = Number(pa[i]);\n        var nb = Number(pb[i]);\n        if (na > nb) return 1;\n        if (nb > na) return -1;\n        if (!isNaN(na) && isNaN(nb)) return 1;\n        if (isNaN(na) && !isNaN(nb)) return -1;\n    }\n    return 0;\n};\n","/**\n * @hidden\n */\n/**\n * Need a comment block here so that the comment block above is interpreted as a file comment, and not a comment on the\n * import below.\n *\n * @hidden\n */\nimport { Events } from './internal';\n\n/**\n * Validates and returns the provided function\n */\nexport function sanitizeFunction<T, U extends any[]>(value: (...args: U) => T): (...args: U) => T {\n  if (typeof value !== 'function') {\n    throw new Error(\n      `Invalid argument passed: ${safeStringify(\n        value,\n        'The provided value'\n      )} is not a valid function`\n    );\n  }\n\n  return value;\n}\n\n/**\n * Validates the provided event type\n */\nexport function sanitizeEventType<E extends Events>(eventType: E['type']): E['type'] {\n  if (\n    eventType === 'notification-action' ||\n    eventType === 'notification-created' ||\n    eventType === 'notification-closed' ||\n    eventType === 'notifications-count-changed' ||\n    eventType === 'notification-form-submitted'\n  ) {\n    return eventType;\n  }\n\n  throw new Error(\n    `Invalid argument passed: ${safeStringify(\n      eventType,\n      'The provided event type'\n    )} is not a valid Notifications event type`\n  );\n}\n\n/**\n * Validates we're running inside an OpenFin environment\n */\nexport function validateEnvironment(): void {\n  if (typeof fin === 'undefined') {\n    throw new Error(\n      'fin is not defined. The openfin-notifications module is only intended for use in an OpenFin application.'\n    );\n  }\n}\n\nexport function safeStringify(value: unknown, fallback: string): string {\n  // Provided object may not be stringify-able (e.g., due to circular references), so we need to try-catch\n  let result: string;\n  try {\n    result = JSON.stringify(value);\n  } catch (e) {\n    result = fallback;\n  }\n\n  return result;\n}\n","/**\n * @module Notifications\n */\n\n/**\n * Lists possible semantic use-cases for notifications, which can alter how the notification is presented to the user.\n *\n * Additional indicator types may be added in future releases.\n */\nexport enum IndicatorType {\n  FAILURE = 'failure',\n  WARNING = 'warning',\n  SUCCESS = 'success',\n}\n\nexport interface NotificationIndicator {\n  /**\n   * Indicates the semantic intent behind the indicator - this determines the visual styling of the indicator when\n   * seen by the user.\n   *\n   * For example - an indicator could be used to:\n   * - `IndicatorType.FAILURE`: Indicate a failure has occurred from an action the user has taken.\n   * - `IndicatorType.WARNING`: Warn a user that they have a limited amount of time to buy.\n   * - `IndicatorType.SUCCESS`: Inform the user that an item has been successfully ordered.\n   */\n  type: IndicatorType;\n\n  /**\n   * Customized text to be displayed in the indicator. When set, this will override the default indicator text.\n   * Text is limited to 32 characters including spaces.\n   */\n  text?: string;\n}\n","export * from './fields';\nexport * from './widgets';\n","/**\n * When you make a form, you provide a list of [[FormFields]]. Each FormField contains the ingredients to make a single widget in the form.\n * The actual definitions of the widgets are derived from [[BaseWidgetSpec]].\n *\n * A FormField contains the type of data, the key to store the user input into [[CustomDataWithForms]], and some additional configuration.\n * @module FormFields\n */\n\n/**\n * imports.\n */\nimport { StringWidget, NumberWidget, BooleanWidget } from './widgets';\n\n/**\n * Data type of a fields. e.g. string, number\n */\nexport const FieldType = {\n  string: 'string',\n  number: 'number',\n  boolean: 'boolean',\n  // date = \"date\"\n} as const;\n\n/**\n * An abstract validation entry.\n */\nexport interface ValidationEntry<T = any> {\n  /**\n   * Message displayed to the user when input is invalid.\n   */\n  invalidMessage?: string;\n  /**\n   * Validation argument to test against.\n   */\n  arg?: T;\n}\n\n/**\n * The base type for form fields.\n */\nexport interface BaseField<T extends keyof typeof FieldType, D = unknown> {\n  /**\n   * Field data type.\n   */\n  type: T;\n  /**\n   * The property key that this field value will appear in the returned {@link NotificationFormSubmittedEvent.form|form} object.\n   */\n  key: string;\n  /**\n   * Default value for field, and where it will be written to\n   */\n  value?: D;\n  /**\n   * Validation rules used to validate user input.\n   */\n  validation?: Record<string, any>;\n  /**\n   * Input label.\n   */\n  label?: string;\n}\n\n/**\n * String field within a form.\n */\nexport interface StringField<W extends StringWidget = StringWidget>\n  extends BaseField<'string', string> {\n  validation?: Partial<{\n    /**\n     * Minimum number of characters.\n     */\n    min: ValidationEntry<number>;\n    /**\n     * Maximum number of characters.\n     */\n    max: ValidationEntry<number>;\n    /**\n     * Length of the input string.\n     */\n    length: ValidationEntry<number>;\n    /**\n     * The field is required to be filled in by the user.\n     */\n    required: ValidationEntry;\n    /**\n     * Provide a regex string that will be tested against the input value.\n     */\n    match: ValidationEntry<string>;\n  }>;\n  /**\n   * What input widget is used.\n   * @default StringWidgets {@link StringWidgets}\n   */\n  widget: W;\n}\n\n/**\n * Number field within a form.\n */\nexport interface NumberField<W extends NumberWidget = NumberWidget>\n  extends BaseField<'number', number> {\n  validation?: Partial<{\n    /**\n     * Minimum number of characters.\n     */\n    min: ValidationEntry<number>;\n    /**\n     * Maximum number of characters.\n     */\n    max: ValidationEntry<number>;\n    /**\n     * Number must be less than this.\n     */\n    lessThan: ValidationEntry<number>;\n    /**\n     * Number must be more than this.\n     */\n    moreThan: ValidationEntry<number>;\n    /**\n     * Number must be positive.\n     */\n    positive: ValidationEntry;\n    /**\n     * Number must be negative.\n     */\n    negative: ValidationEntry;\n    /**\n     * The field is required to be filled in by the user.\n     */\n    required: ValidationEntry;\n  }>;\n  widget: W;\n}\n\nexport interface BooleanField<W extends BooleanWidget = BooleanWidget>\n  extends BaseField<'boolean', boolean> {\n  widget: W;\n}\n\n/**\n * A field in a form.\n */\nexport type FormField = StringField | NumberField | BooleanField;\n\n/**\n * An ordered array of fields representing a form.\n * When the form is displayed to the user the fields will appear in the same order they are in the array.\n */\nexport type NotificationFormData = ReadonlyArray<FormField>;\n","/**\n * These are available widgets for use in forms.\n *\n * @module FormWidgets\n */\n\n// I have left commented out examples of other widget types to aid\n// others in implementing new widgets.\n\n/**\n * The StringWidgetType is how you display a text string.\n */\nexport const StringWidgetType = {\n  Text: 'Text',\n  // TextArea: 'TextArea',\n  // Color: 'Color'\n} as const;\n\nexport const NumberWidgetType = {\n  Number: 'Number',\n} as const;\n\nexport const BooleanWidgetType = {\n  Toggle: 'Toggle',\n\tCheckbox: 'Checkbox'\n} as const;\n\nexport const WidgetType = {\n  ...StringWidgetType,\n  ...NumberWidgetType,\n  ...BooleanWidgetType,\n} as const;\n\n/**\n * All available widgets.\n */\nexport type Widget = StringWidget | NumberWidget | BooleanWidget;\n\nexport interface BaseWidgetSpec<T extends keyof typeof WidgetType> {\n  /**\n   * The type of widget to be used. Widgets can only be used with matching specific data types.\n   * For example the `Text` widget can be used with the `string` field type.\n   */\n  type: T;\n}\n\n/**\n * A simple text field input widget.\n */\nexport interface TextWidgetSpec extends BaseWidgetSpec<typeof WidgetType['Text']> {\n  placeholder?: string;\n}\n\n/**\n * String field input widget.\n */\nexport type StringWidget = TextWidgetSpec;\n\nexport interface NumberWidgetSpec extends BaseWidgetSpec<typeof WidgetType['Number']> {\n  placeholder?: string;\n  min?: number;\n  max?: number;\n}\n\n/**\n * Number field input widget.\n */\nexport type NumberWidget = NumberWidgetSpec;\n\nexport type ToggleWidgetSpec = BaseWidgetSpec<typeof WidgetType['Toggle']>;\nexport type CheckboxWidgetSpec = BaseWidgetSpec<typeof WidgetType['Checkbox']>;\n\nexport type BooleanWidget = ToggleWidgetSpec | CheckboxWidgetSpec;\n\n// export interface MultiOption<T = unknown> {\n//     display?: string;\n//     value: T;\n// }\n\n// export interface SelectWidget<T = string | number> extends BaseWidget<typeof WidgetType['Select']> {\n//     options: MultiOption<T>[];\n//     placeholder?: string;\n// }\n\n// export interface RadioButtonGroupWidget extends BaseWidget<typeof WidgetType['RadioButtonGroup']> {\n//     options: MultiOption[];\n//     placeholder?: string;\n// }\n\n// export type MultiWidgets = SelectWidget | RadioButtonGroupWidget;\n","export * from './BaseNotificationOptions';\nexport * from './templates';\n"],"sourceRoot":""}