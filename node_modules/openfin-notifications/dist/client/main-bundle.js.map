{"version":3,"sources":["webpack://notifications/webpack/universalModuleDefinition","webpack://notifications/webpack/bootstrap","webpack://notifications/./src/client/internal.ts","webpack://notifications/./src/client/actions.ts","webpack://notifications/./src/client/connection.ts","webpack://notifications/./node_modules/openfin-service-async/index.js","webpack://notifications/./node_modules/openfin-service-async/DeferredPromise.js","webpack://notifications/./src/client/templates/templates.ts","webpack://notifications/./src/client/index.ts","webpack://notifications/./node_modules/events/events.js","webpack://notifications/./node_modules/openfin-service-async/async.js","webpack://notifications/./src/client/EventRouter.ts","webpack://notifications/./src/client/provider.ts","webpack://notifications/./node_modules/semver-compare/index.js","webpack://notifications/./src/client/validation.ts","webpack://notifications/./src/client/indicator.ts","webpack://notifications/./src/client/controls.ts","webpack://notifications/./src/client/source.ts","webpack://notifications/./src/client/forms/index.ts","webpack://notifications/./src/client/forms/fields.ts","webpack://notifications/./src/client/forms/widgets.ts","webpack://notifications/./src/client/stream.ts","webpack://notifications/./src/client/templates/index.ts","webpack://notifications/./src/client/templates/BaseNotificationOptions.ts"],"names":[],"mappings":"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;;;;GAQG;AACI,KAAK,UAAU,wBAAwB;IAC5C,OAAO,+BAAkB,CAAC,mBAAQ,CAAC,0BAA0B,EAAE,SAAS,CAAC,CAAC;AAC5E,CAAC;AAFD,4DAEC;AAED;;;;;;;;GAQG;AACI,KAAK,UAAU,qBAAqB;IACzC,OAAO,+BAAkB,CAAC,mBAAQ,CAAC,uBAAuB,EAAE,SAAS,CAAC,CAAC;AACzE,CAAC;AAFD,sDAEC;;;;;;;;ACteD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,sBAAsB;AACvC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,QAAQ,yBAAyB;AACjC;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,6DAA6D,aAAa;AAC1E;AACA,6DAA6D,aAAa;AAC1E;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,oCAAoC,aAAa;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;;;;;;;AChfa;AACb,8CAA8C,cAAc;AAC5D,0BAA0B,mBAAO,CAAC,CAAmB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,EAAE;AAC3B;AACA;AACA;;;;;;;;;AC5HA;;GAEG;;;;;;;;;;;;;;AAoCH;;GAEG;AACH,MAAa,WAAW;IAMtB,YAAmB,cAA4B;QAC7C,IAAI,CAAC,iBAAiB,GAAG,EAAE,CAAC;QAC5B,IAAI,CAAC,cAAc,GAAG,EAAE,CAAC;QAEzB,IAAI,CAAC,eAAe,GAAG,cAAc,CAAC;IACxC,CAAC;IAEM,uBAAuB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","file":"main-bundle.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"notifications\"] = factory();\n\telse\n\t\troot[\"notifications\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n","/**\n * @hidden\n */\n\n/**\n * File contains types used to communicate between client and provider.\n *\n * These types are a part of the client, but are not required by applications wishing to interact with the service.\n * This file is excluded from the public-facing TypeScript documentation.\n */\n\nimport { NotificationActionResult, ActionTrigger } from './actions';\nimport { ProviderStatus } from './provider';\nimport { NotificationSource } from './source';\n\nimport {\n  NotificationOptions,\n  Notification,\n  NotificationActionEvent,\n  NotificationClosedEvent,\n  NotificationCreatedEvent,\n  NotificationsCountChanged,\n  NotificationFormSubmittedEvent,\n} from './index';\n\n/**\n * The identity of the main application window of the service provider\n */\nexport const SERVICE_IDENTITY = {\n  uuid: 'notifications-service',\n  name: 'notifications-service',\n};\n\n/**\n * Name of the IAB channel use to communicate between client and provider\n */\nexport const SERVICE_CHANNEL = 'of-notifications-service-v1';\n\nexport const enum APITopic {\n  CREATE_NOTIFICATION = 'create-notification',\n  CLEAR_NOTIFICATION = 'clear-notification',\n  GET_APP_NOTIFICATIONS = 'fetch-app-notifications',\n  CLEAR_APP_NOTIFICATIONS = 'clear-app-notifications',\n  TOGGLE_NOTIFICATION_CENTER = 'toggle-notification-center',\n  ADD_EVENT_LISTENER = 'add-event-listener',\n  REMOVE_EVENT_LISTENER = 'remove-event-listener',\n  GET_PROVIDER_STATUS = 'get-provider-status',\n  GET_NOTIFICATIONS_COUNT = 'get-notifications-count',\n}\n\nexport interface API {\n  [APITopic.CREATE_NOTIFICATION]: [CreatePayload, NotificationInternal];\n  [APITopic.CLEAR_NOTIFICATION]: [ClearPayload, boolean];\n  [APITopic.CLEAR_APP_NOTIFICATIONS]: [undefined, number];\n  [APITopic.GET_APP_NOTIFICATIONS]: [undefined, NotificationInternal[]];\n  [APITopic.TOGGLE_NOTIFICATION_CENTER]: [undefined, void];\n  [APITopic.ADD_EVENT_LISTENER]: [Events['type'], void];\n  [APITopic.REMOVE_EVENT_LISTENER]: [Events['type'], void];\n  [APITopic.GET_PROVIDER_STATUS]: [undefined, ProviderStatus];\n  [APITopic.GET_NOTIFICATIONS_COUNT]: [undefined, number];\n}\n\nexport type Events =\n  | NotificationActionEvent\n  | NotificationClosedEvent\n  | NotificationCreatedEvent\n  | NotificationsCountChanged\n  | NotificationFormSubmittedEvent;\n\nexport type TransportMappings<T> = T extends NotificationActionEvent\n  ? NotificationActionEventTransport\n  : never;\nexport type TransportMemberMappings<T> = T extends Notification ? NotificationInternal : T;\n\nexport type CreatePayload<T extends NotificationOptions = NotificationOptions> = DistributiveOmit<\n  T,\n  'date' | 'expires'\n> & {\n  date?: number;\n  expires?: number | null;\n};\n\nexport type NotificationInternal<\n  T extends NotificationOptions = NotificationOptions\n> = DistributiveOmit<Notification<T>, 'date' | 'expires'> & {\n  date: number;\n  expires: number | null;\n};\n\nexport interface ClearPayload {\n  id: string;\n}\n\nexport interface NotificationActionEventTransport {\n  type: 'notification-action';\n  notification: Readonly<NotificationInternal>;\n  source: NotificationSource;\n  result: NotificationActionResult;\n  trigger: ActionTrigger;\n\n  // Following are present only if trigger is `ActionTrigger.CONTROL`\n  controlSource?: 'buttons'; // Additional sources will be added in future release\n  controlIndex?: number; // The index of the originating control, within notification[controlSource]\n}\n\n/**\n * Distribute Omit across all union types instead of Omitting the union.\n * https://davidgomes.com/pick-omit-over-union-types-in-typescript/\n */\nexport type DistributiveOmit<T, K extends keyof T> = T extends unknown ? Omit<T, K> : never;\n","/**\n * Actions are the mechanism through which notifications send messages back to the application that created them. The\n * service defines a number of ways in which actions can be raised (a notification being interacted with by the user,\n * being closed, expiring, etc.), and it is up to each application to decide if it wishes to be informed when each of\n * these triggers occur.\n *\n * For an action to be raised when one of these triggers occurs, the application must specify an\n * {@link NotificationActionResult|action result} for each trigger it is interested in. The application should then\n * listen for when these actions are raised by listening for the {@link NotificationActionEvent|`notification-action`}\n * event.\n *\n * This event is fired once each time an action is raised, and will contain the\n * {@link NotificationActionResult|action result} the application specified for that trigger. The application may then\n * use the {@link NotificationActionResult|action result} to determine which trigger occurred and respond appropriately.\n *\n * If an {@link NotificationActionResult|action result} is not specified for a particular trigger, or it is set to\n * `null`, the application will not receive a corresponding {@link NotificationActionEvent|`notification-action`} when\n * that trigger occurs.\n *\n * Unlike other event types, {@link NotificationActionEvent|`notification-action`} events will be buffered by the\n * service until the application has added a listener for this event type, at which point it will receive all buffered\n * {@link NotificationActionEvent|`notification-action`} events. The service will also attempt to restart the\n * application if it is not running when the event is fired.\n *\n * For an overview of actions, consider the sample notification below:\n * ```ts\n * import {addEventListener, create} from 'openfin-notifications';\n *\n * // Create a notification with two buttons\n * create({\n *     // Basic info\n *     title: 'Reminder',\n *     body: 'Event \"Weekly Meeting\" is starting soon...',\n *     category: 'Upcoming Events',\n *\n *     // We'll use the 'customData' field to store metadata about the event\n *     customData: {eventId: '12345'},\n *\n *     // We want the user clicking the notification to open the associated event, so register an 'onSelect' action\n *     onSelect: {task: 'view-calendar-event', target: 'popup'},\n *\n *     buttons: [\n *         // A button that will schedule another reminder for 5 minutes from now. Since the application will be\n *         // responsible for snoozing the event, it will need to know about the user clicking this button. By setting\n *         // a NotificationActionResult for 'onClick', the service will raise a \"notification-action\" event when this\n *         // button is clicked, and will pass the value of 'onClick' as the 'result' field within the event\n *         {\n *             title: 'Snooze for 5 minutes',\n *             iconUrl: 'https://www.example.com/timer.png',\n *             onClick: {\n *                 task: 'schedule-reminder',\n *                 intervalMs: 5 * 60 * 1000\n *             }\n *         },\n *\n *         // A button that closes the notification and doesn't prompt the user about this event again. Since the\n *         // application doesn't need to do anything when the user clicks this button, we leave 'onClick' undefined\n *         // rather than specifying a NotificationActionResult. This means that no action will be raised when the\n *         // button is clicked, and hence no \"notification-action\" event will be fired\n *         {\n *             title: 'Dismiss',\n *             iconUrl: 'https://www.example.com/cancel.png'\n *         }\n *     ]\n * });\n *\n * // Create a listener that will be called for each action\n * // Note: This handler will be used for ALL actions, from ALL notifications that are created by this application.\n * addEventListener('notification-action', (event: NotificationActionEvent) => {\n *     const {result, notification} = event;\n *\n *     if (result['task'] === 'view-calendar-event') {\n *         // Open a window with full details of the associated event\n *         openEventDetails(notification.customData.eventId, result['target']);\n *     } else if (result['task'] === 'schedule-reminder') {\n *         // Schedule a new notification\n *         scheduleReminder(notification.customData.eventId, Date.now() + result['intervalMs']);\n *     } // Etc...\n * });\n * ```\n *\n * The example above uses `customData` to store details about the notification subject (in this case, a calendar\n * event), and `onClick` actions to inform the application about how it should respond when the user interacts with the\n * notification. This is our intended usage and recommended best-practice, but the service doesn't require applications\n * to follow this convention - application developers are free to decide how to manage notification state.\n *\n * Within the `notification-action` handler, the application must be able to understand which notification is being\n * handled, and how to decide what it should do next. The example above uses an application-defined `action` field to\n * determine the correct action, but the notification's `id`, `category`, `customData` and other fields are also useful\n * selectors.\n *\n * @module Actions\n */\n\n/**\n * Need a comment block here so that the comment block above is interpreted as a file comment, and not a comment on the\n * import below.\n *\n * @hidden\n */\nimport { CustomData } from '.';\n\n/**\n * Denotes a field as being an action. Defining this field (with a non-`undefined` value) will result in actions being\n * raised and sent back to the source application when the corresponding event happens.\n *\n * For example, providing a value for the `onClick` field of {@link ButtonOptions} will result in a\n * {@link NotificationActionEvent|`notification-action`} event being fired when that button is clicked.\n *\n * In the current version of the service, the `NotificationActionResult`s returned back to an application are static\n * and must bedefined at the point where the notification is created. Later versions of the service will allow some\n * limited programmatic creation of these results, for use in situations where static result data isn't sufficient.\n *\n * The generic parameters of this type are for future expansion. Future versions of the service will allow for more\n * control over the handling of actions.\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport type ActionDeclaration<T extends never, E extends never> = NotificationActionResult;\n\n/**\n * Data type used to represent the action result returned back to applications when an action is raised. Applications\n * capture these responses by adding a `notification-action` listener. The contents of this type are entirely\n * application-defined, the only requirement is that the item is serializable by `JSON.stringify`.\n *\n * Since this type is entirely application-specific, the type  is used in these definitions. However, there is an\n * optional generic argument here, which can be used if an application were to define its own conventions for the shape\n * of this field (which is recommended). To make use of this, define a `notification-action` handler that includes the\n * application-defined type as a template argument. This type is then propogated up to {@link NotificationActionEvent}.\n * The example below demonstrates this, using the same use-case as at the top of this page.\n *\n * ```ts\n * interface MyAction = SnoozeAction | DetailsAction;\n *\n * interface SnoozeAction {\n *     task: 'schedule-reminder';\n *     intervalMs: number;\n * }\n *\n * interface DetailsAction {\n *     task: 'view-calendar-event';\n *     target: 'self'|'popup';\n * }\n *\n * addEventListener('notification-action', (event: NotificationActionEvent<MyAction>)) => {\n *     if (event.result.task === 'schedule-reminder') {\n *         // 'event.result' will now be strongly-typed as an instance of SnoozeAction\n *         scheduleReminder(notification.customData.eventId, Date.now() + result.intervalMs);\n *     }\n *     // Etc...\n * });\n * ```\n */\nexport type NotificationActionResult<T = CustomData> = T;\n\n/**\n * Lists the different triggers that can raise an {@link Actions|action}. Each action that is raised will result in a\n * {@link NotificationActionEvent|`notification-action`} event, which can be captured by the application that created\n * the notification.\n */\nexport enum ActionTrigger {\n  /**\n   * The user interacted with one of the controls within the notification. This currently means a button click, but\n   * other control types will be added in future releases.\n   */\n  CONTROL = 'control',\n\n  /**\n   * The user clicked the body of the notification itself. Any clicks of the notification that don't hit a control\n   * or the close button will fire an event with the `'select'` action trigger.\n   */\n  SELECT = 'select',\n\n  /**\n   * The notification was closed, either by user interaction, programmatically by an application, or by the notification expiring.\n   */\n  CLOSE = 'close',\n\n  /**\n   * The notification expired.\n   */\n  EXPIRE = 'expire',\n\n  /**\n   * The action was triggered programmatically by an application.\n   *\n   * *Not currently supported - will be implemented in a future release*\n   */\n  PROGRAMMATIC = 'programmatic',\n}\n\n/**\n * Noop action types see {@link ActionNoop|ActionNoop}.\n */\nexport enum ActionNoopType {\n  /**\n   * No event will be raised and no dismissal of the notification on action.\n   */\n  EVENT_DISMISS = 'event_dismiss',\n  /**\n   * No event will be raised, but the notification will be dismissed on action.\n   */\n  // EVENT = 'event',\n  /**\n   * No dismissal of the notification, but the action event will be raised on action.\n   */\n  // DISMISS = 'dismiss',\n}\n\n/**\n * Setting the `__NOOP__` field on an action with a {@link ActionNoopType|type} allows you to override default user interaction with a notification.\n *\n * For example, creating a notification:\n * ```\n * const notification = {\n *  //...\n *  onSelect: {__NOOP__: ActionNoopType.EVENT_DISMISS}\n * };\n * ```\n * When a user clicks the notification body, the notification will not be dismissed and no event will be raised to the client application.\n *\n * **Currently `ActionNoopType.EVENT_DISMISS` is only supported by `ActionTrigger.SELECT`/`onSelect`.**\n */\nexport interface ActionNoop {\n  __NOOP__?: ActionNoopType;\n}\n","/**\n * @hidden\n */\n\n/**\n * File contains vars used to establish service connection between client and provider.\n *\n * These are separated out from 'internal.ts' as including these from provider code will cause the provider to connect\n * to itself.\n *\n * These types are a part of the client, but are not required by applications wishing to interact with the service.\n * This file is excluded from the public-facing TypeScript documentation.\n */\nimport { EventEmitter } from 'events';\n\nimport { ChannelClient } from 'openfin/_v2/api/interappbus/channel/client';\nimport { DeferredPromise } from 'openfin-service-async';\n\nimport { APITopic, SERVICE_CHANNEL, API, SERVICE_IDENTITY, Events } from './internal';\nimport { EventRouter, Targeted, Transport } from './EventRouter';\n\n/**\n * The version of the NPM package.\n *\n * Webpack replaces any instances of this constant with a hard-coded string at build time.\n */\ndeclare const PACKAGE_VERSION: string;\n\n/**\n * The event emitter to emit events received from the service.  All addEventListeners will tap into this.\n */\nexport const eventEmitter = new EventEmitter();\n\n/**\n * Promise to the channel object that allows us to connect to the client\n */\nlet channelPromise: Promise<ChannelClient> | null;\nconst hasDOMContentLoaded = new DeferredPromise<void>();\nlet reconnect = false;\n\nconst MIN_API_VERSION = 53;\n\nif (typeof fin !== 'undefined') {\n  launchSystemApp();\n  getServicePromise();\n  if (document.readyState !== 'loading') {\n    hasDOMContentLoaded.resolve();\n  } else {\n    window.addEventListener('DOMContentLoaded', () => {\n      hasDOMContentLoaded.resolve();\n    });\n    document.addEventListener('DOMContentLoaded', () => {\n      hasDOMContentLoaded.resolve();\n    });\n  }\n}\n\nasync function launchSystemApp() {\n  if (!window.navigator.appVersion.includes('Windows')) {\n    // Mac has an RVM now\n    fin.System.openUrlWithBrowser('fins://system-apps/notification-center');\n    return;\n  }\n  try {\n    const info = await fin.System.getRvmInfo();\n    const major = parseInt(info.version.split('.')[0]);\n    if (major >= 6) {\n      // @ts-ignore\n      if (fin.System.launchManifest) {\n        // Launch with no ui in newer runtimes that support the `launchManifest` api.\n        // @ts-ignore\n        fin.System.launchManifest('fins://system-apps/notification-center', { noUi: true }).catch(\n          (error: Error) => {\n            console.error('Unable to launch the Notification Center as a system app', error);\n          }\n        );\n      } else {\n        // Fallback to launching with ui\n        fin.System.openUrlWithBrowser('fins://system-apps/notification-center').catch(() => {});\n      }\n    }\n  } catch (e) {\n    // Do nothing\n  }\n}\n\nexport async function getServicePromise(): Promise<ChannelClient> {\n  await hasDOMContentLoaded.promise;\n  if (!channelPromise) {\n    if (typeof fin === 'undefined') {\n      const msg =\n        'fin is not defined. The openfin-notifications module is only intended for use in an OpenFin application.';\n      channelPromise = Promise.reject(new Error(msg));\n      return channelPromise;\n    }\n\n    // You can't use an `await` here. If you do, you introduce a race condition that makes this function non-reentrant, and you end\n    // up with multiple connections to the provider. So don't do that.\n    fin.System.getVersion().then((v) => {\n      const apiVersion = parseInt(v.split('.')[2]);\n      if (apiVersion < MIN_API_VERSION) {\n        console.warn(\n          `API version ${apiVersion} of OpenFin version ${v} is less than ${MIN_API_VERSION}. Please upgrade the runtime version.`\n        );\n      }\n    });\n\n    // @ts-ignore fin.me has no types yet\n    const { name, uuid } = fin.me?.identity ?? fin.Window.me;\n    if (uuid === SERVICE_IDENTITY.uuid && name === SERVICE_IDENTITY.name) {\n      // Currently a runtime bug when provider connects to itself. Ideally the provider would never import a file\n      // that includes this, but for now it is easier to put a guard in place.\n      channelPromise = Promise.reject(new Error('Trying to connect to provider from provider'));\n    } else {\n      const timeoutHandle = window.setTimeout(() => {\n        console.warn(\n          'Taking a long time to connect to Notifications service. Is the Notifications service running?'\n        );\n      }, 5000);\n\n      channelPromise = fin.InterApplicationBus.Channel.connect(SERVICE_CHANNEL, {\n        wait: true,\n        payload: { version: PACKAGE_VERSION },\n      }).then((channel: ChannelClient) => {\n        window.clearTimeout(timeoutHandle);\n\n        const eventRouter = getEventRouter();\n\n        // Register service listeners\n        channel.register('WARN', (payload: unknown) => console.warn(payload));\n        channel.register('event', (event: Targeted<Transport<Events>>) => {\n          eventRouter.dispatchEvent(event);\n        });\n        // Any unregistered action will simply return false\n        channel.setDefaultAction(() => false);\n\n        channel.onDisconnection(() => {\n          console.warn('Disconnected from Notifications service');\n          reconnect = true;\n          channelPromise = null;\n          // Relaunch notifications incase it was launched as a service first\n          launchSystemApp();\n          setTimeout(() => {\n            console.log('Attempting to reconnect to Notifications service');\n            getServicePromise();\n          }, 300);\n        });\n\n        if (reconnect) {\n          console.log('Reconnected to Notifications service');\n        } else {\n          console.log('Connected to Notifications service');\n        }\n\n        return channel;\n      });\n    }\n  }\n\n  return channelPromise;\n}\n\n/**\n * Wrapper around service.dispatch to help with type checking\n * @param action Action type.\n * @param payload Data payload to send to the provider.\n */\nexport async function tryServiceDispatch<T extends APITopic>(\n  action: T,\n  payload: API[T][0]\n): Promise<API[T][1]> {\n  const channel: ChannelClient = await getServicePromise();\n  return channel.dispatch(action, payload) as Promise<API[T][1]>;\n}\n\nlet eventRouter: EventRouter<Events> | null;\n\nexport function getEventRouter(): EventRouter<Events> {\n  if (!eventRouter) {\n    eventRouter = new EventRouter(eventEmitter);\n  }\n\n  return eventRouter;\n}\n","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./async\"));\n__export(require(\"./DeferredPromise\"));\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass DeferredPromise {\n    constructor() {\n        const promise = new Promise((res, rej) => {\n            this._resolve = res;\n            this._reject = rej;\n        });\n        this._promise = promise;\n    }\n    get promise() {\n        return this._promise;\n    }\n    get resolve() {\n        return this._resolve;\n    }\n    get reject() {\n        return this._reject;\n    }\n}\nexports.DeferredPromise = DeferredPromise;\n","/**\n * These are the templates you can use.\n *\n * @module Templates\n */\n\n/**\n * imports\n */\nimport { NotificationFormData } from '../forms/fields';\n\nimport { BaseNotificationOptions } from './BaseNotificationOptions';\n\n/**\n * The options you pass to the [[create]] function to generate a notification.\n */\nexport type NotificationOptions = TemplateMarkdown | TemplateList;\n\nexport const TemplateNames = {\n  markdown: 'markdown',\n  list: 'list',\n} as const;\n\n/**\n * Default markdown template. Contains a markdown body and forms data.\n */\nexport interface TemplateMarkdown extends Omit<BaseNotificationOptions<'markdown'>, 'template'> {\n  template?: 'markdown';\n  /**\n   * Notification body text.\n   *\n   * This is the main notification content, displayed below the notification title. The notification will expand to fit the length of this text.\n   * Markdown may be used in the body text to control how it is styled when rendered.\n   * With the exception of links and code blocks, all basic syntax as documented [here](https://www.markdownguide.org/basic-syntax) is supported.\n   */\n  body: string;\n\n  form?: NotificationFormData | null;\n}\n\n/**\n * Simple template that can render a list of name-value pairs.\n */\nexport interface TemplateList extends BaseNotificationOptions<'list'> {\n  /**\n   * Notification list template data.\n   */\n  list: Record<string, string>;\n}\n","/* eslint-disable no-redeclare */\n/**\n * @module NotificationCenter\n */\n\n/**\n * Need a comment block here so that the comment block above is interpreted as a file comment, and not a comment on the\n * import below.\n *\n * @hidden\n */\nimport { NotificationActionResult, ActionTrigger } from './actions';\nimport { tryServiceDispatch, eventEmitter, getEventRouter } from './connection';\nimport { ButtonOptions, ControlOptions } from './controls';\nimport {\n  APITopic,\n  CreatePayload,\n  DistributiveOmit,\n  Events,\n  NotificationInternal,\n} from './internal';\nimport { EventRouter, Transport } from './EventRouter';\nimport * as provider from './provider';\nimport { NotificationSource } from './source';\nimport { validateEnvironment, sanitizeEventType, sanitizeFunction } from './validation';\nimport { NotificationIndicator, IndicatorType } from './indicator';\nimport { NotificationOptions } from './templates/templates';\n\nexport * from './actions';\nexport * from './controls';\nexport * from './source';\nexport * from './forms';\nexport * from './stream';\nexport * from './templates';\n\nexport { provider, NotificationOptions };\nexport { NotificationIndicator, IndicatorType as NotificationIndicatorType };\n\n/**\n * The version of the NPM package.\n *\n * Webpack replaces any instances of this constant with a hard-coded string at build time.\n */\ndeclare const PACKAGE_VERSION: string;\n\n/**\n * The Notification Client library's version in semver format.\n *\n * This is the version which you are currently using.\n */\nexport const VERSION = PACKAGE_VERSION;\n\nconst eventHandler: EventRouter<Events> = getEventRouter();\n\nfunction parseEventWithNotification<T extends { notification: NotificationInternal }>(\n  event: T\n): T & { notification: Notification } {\n  const { notification } = event;\n\n  return {\n    ...event,\n    notification: {\n      ...notification,\n      date: new Date(notification.date),\n      expires: notification.expires !== null ? new Date(notification.expires) : null,\n    } as Notification,\n  };\n}\n\neventHandler.registerDeserializer<NotificationCreatedEvent>(\n  'notification-created',\n  (event: Transport<NotificationCreatedEvent>) => {\n    return parseEventWithNotification(event);\n  }\n);\neventHandler.registerDeserializer<NotificationClosedEvent>(\n  'notification-closed',\n  (event: Transport<NotificationClosedEvent>) => {\n    return parseEventWithNotification(event);\n  }\n);\neventHandler.registerDeserializer<NotificationActionEvent>(\n  'notification-action',\n  (event: Transport<NotificationActionEvent>) => {\n    const { controlSource, controlIndex, ...rest } = parseEventWithNotification(event);\n\n    if (event.trigger === ActionTrigger.CONTROL) {\n      const control = event.notification[controlSource!][controlIndex!];\n      return { ...rest, control };\n    } else {\n      return rest;\n    }\n  }\n);\n\neventHandler.registerDeserializer<NotificationsCountChanged>(\n  'notifications-count-changed',\n  (event: Transport<NotificationsCountChanged>) => {\n    return event;\n  }\n);\n\n/**\n * Application-defined context data that can be attached to buttons on notifications.\n */\nexport type CustomData = Record<string, any>;\n\n/**\n * A fully-hydrated form of {@link NotificationOptions}.\n *\n * After {@link create|creating} a notification, the service will return an object of this type. This will be the given\n * options object, with any unspecified fields filled-in with default values.\n *\n * This object should be treated as immutable. Modifying its state will not have any effect on the notification or the\n * state of the service.\n */\nexport type Notification<T extends NotificationOptions = NotificationOptions> = Readonly<\n  Required<DistributiveOmit<T, 'buttons'>> & {\n    readonly buttons: ReadonlyArray<Required<ButtonOptions>>;\n  }\n>;\n\n/**\n * Event fired when an action is raised for a notification due to a specified trigger. It is important to note that\n * applications will only receive these events if they indicate to the service that they want to receive these events.\n * See {@link Actions} for a full example of how actions are defined, and how an application can listen to and handle\n * them.\n *\n * This can be fired due to interaction with notification buttons or the notification itself, the notification being\n * closed (either by user interaction or by API call), or by the notification expiring. Later versions of the service\n * will add additional control types that may raise actions from user interaction. All actions, for all control types,\n * will be returned to the application via the same `notification-action` event type.\n *\n * The event object will contain the application-defined {@link NotificationActionResult|metadata} that allowed this\n * action to be raised, and details on what triggered this action and which control the user interacted with.\n *\n * Unlike other event types, `notification-action` events will be buffered by the service until the application has\n * added a listener for this event type, at which point it will receive all buffered `notification-action` events. The\n * service will also attempt to restart the application if it is not running when the event is fired.\n *\n * This type includes a generic type argument, should applications wish to define their own interface for action\n * results. See {@link NotificationActionResult} for details.\n *\n * @event \"notification-action\"\n */\nexport interface NotificationActionEvent<T = CustomData> {\n  type: 'notification-action';\n\n  /**\n   * The notification that created this action\n   */\n  notification: Readonly<Notification>;\n\n  /**\n   * This property allows the application handling the action to identify where this notification originated.\n   */\n  source: NotificationSource;\n\n  /**\n   * Indicates what triggered this action.\n   *\n   * Note that the `programmatic` trigger is not yet implemented.\n   */\n  trigger: ActionTrigger;\n\n  /**\n   * The control whose interaction resulted in this action being raised. Will only be present when {@link trigger} is\n   * {@link ActionTrigger.CONTROL}.\n   *\n   * Future versions of the service will add additional controls beyond buttons, and interactions with these new\n   * control types will also come through this one event type. For best forward-compatibility, applications should\n   * always check the `type` property of this control, and not assume that the type will always be `'button'`.\n   *\n   * This field is marked optional as future versions of the service will also include alternate methods of raising\n   * `notification-action` events that do not originate from a button or other control.\n   *\n   * When present, the object here will always be strictly equal to one of the control definitions within\n   * `notification`. This means `indexOf` checks and other equality checks can be performed on this field if\n   * required, such as:\n   *\n   * ```ts\n   * function onNotificationAction(event: NotificationActionEvent): void {\n   *     if (event.control && event.control.type === 'button') {\n   *         const butttonIndex = event.notification.buttons.indexOf(event.control);\n   *\n   *         // Handle button click\n   *         // . . .\n   *     }\n   * }\n   * ```\n   */\n  control?: Readonly<Required<ControlOptions>>;\n\n  /**\n   * Application-defined metadata that this event is passing back to the application.\n   *\n   * A `notification-action` event is only fired for a given trigger if the\n   * {@link NotificationOptions|notification options} included an action result for that trigger.\n   *\n   * See the comment on the {@link NotificationActionEvent} type for an example of buttons that do and don't raise\n   * actions.\n   */\n  result: NotificationActionResult<T>;\n}\n\n/**\n * Event fired whenever the notification has been closed.\n *\n * This event is fired regardless of how the notification was closed - i.e.: via a call to `clear`/`clearAll`, the\n * notification expiring, or by a user clicking either the notification itself, the notification's close button, or\n * a button on the notification.\n *\n * @event \"notification-closed\"\n */\nexport interface NotificationClosedEvent {\n  type: 'notification-closed';\n\n  /**\n   * The notification that has just been closed.\n   *\n   * This object will match what is returned from the `create` call when the notification was first created.\n   */\n  notification: Notification;\n}\n\n/**\n * Event fired whenever a new notification has been created.\n *\n * @event \"notification-created\"\n */\nexport interface NotificationCreatedEvent {\n  type: 'notification-created';\n\n  /**\n   * The notification that has just been created.\n   *\n   * This object will match what is returned from the `create` call.\n   */\n  notification: Notification;\n}\n\n/**\n * Event fired whenever the total number of notifications from **all** sources changes.\n *\n * @event \"notifications-count-changed\"\n */\nexport interface NotificationsCountChanged {\n  type: 'notifications-count-changed';\n  /**\n   * Number of notifications in the Center.\n   */\n  count: number;\n}\n\nexport interface NotificationFormSubmittedEvent {\n  type: 'notification-form-submitted';\n  notification: Notification;\n  form: Record<string, unknown>;\n}\n\nexport function addEventListener(\n  eventType: 'notification-form-submitted',\n  listener: (event: NotificationFormSubmittedEvent) => void\n): void;\nexport function addEventListener(\n  eventType: 'notification-action',\n  listener: (event: NotificationActionEvent) => void\n): void;\nexport function addEventListener(\n  eventType: 'notification-created',\n  listener: (event: NotificationCreatedEvent) => void\n): void;\nexport function addEventListener(\n  eventType: 'notification-closed',\n  listener: (event: NotificationClosedEvent) => void\n): void;\nexport function addEventListener(\n  eventType: 'notifications-count-changed',\n  listener: (event: NotificationsCountChanged) => void\n): void;\n\n/**\n * Adds a listener, see definitions of individual event interfaces for details on each event.\n *\n * @param eventType The event being subscribed to\n * @param listener The callback function to add\n */\nexport function addEventListener<E extends Events>(\n  eventType: E['type'],\n  listener: (event: E) => void\n): void {\n  validateEnvironment();\n  eventType = sanitizeEventType(eventType);\n  listener = sanitizeFunction(listener);\n\n  const count = eventEmitter.listenerCount(eventType);\n  eventEmitter.addListener(eventType, listener);\n  if (count === 0 && eventEmitter.listenerCount(eventType) === 1) {\n    tryServiceDispatch(APITopic.ADD_EVENT_LISTENER, eventType);\n  }\n}\n\nexport function removeEventListener(\n  eventType: 'notification-form-submitted',\n  listener: (event: NotificationFormSubmittedEvent) => void\n): void;\nexport function removeEventListener(\n  eventType: 'notification-action',\n  listener: (event: NotificationActionEvent) => void\n): void;\nexport function removeEventListener(\n  eventType: 'notification-created',\n  listener: (event: NotificationCreatedEvent) => void\n): void;\nexport function removeEventListener(\n  eventType: 'notification-closed',\n  listener: (event: NotificationClosedEvent) => void\n): void;\nexport function removeEventListener(\n  eventType: 'notifications-count-changed',\n  listener: (event: NotificationsCountChanged) => void\n): void;\n\n/**\n * Removes a listener previously added with {@link addEventListener}.\n *\n * Has no effect if `listener` isn't a callback registered against `eventType`.\n *\n * @param eventType The event being unsubscribed from\n * @param listener The callback function to remove, must be strictly-equal (`===` equivilance) to a listener previously passed to {@link addEventListener} to have an effect\n */\nexport function removeEventListener<E extends Events>(\n  eventType: E['type'],\n  listener: (event: E) => void\n): void {\n  validateEnvironment();\n  eventType = sanitizeEventType(eventType);\n  listener = sanitizeFunction(listener);\n\n  const count = eventEmitter.listenerCount(eventType);\n  eventEmitter.removeListener(eventType, listener);\n  if (count === 1 && eventEmitter.listenerCount(eventType) === 0) {\n    tryServiceDispatch(APITopic.REMOVE_EVENT_LISTENER, eventType);\n  }\n}\n\n/**\n * Creates a new notification.\n *\n * The notification will appear in the Notification Center and as a toast if the Center is not visible.\n *\n * If a notification is created with an `id` of an already existing notification, the existing notification will be recreated with the new content.\n *\n * ```ts\n * import {create} from 'openfin-notifications';\n *\n * create({\n *      id: 'uniqueNotificationId',\n *      title: 'Notification Title',\n *      body: 'Text to display within the notification body',\n *      category: 'Sample Notifications',\n *      icon: 'https://openfin.co/favicon.ico'\n * });\n * ```\n *\n * @param options Notification configuration options.\n */\nexport async function create<T extends NotificationOptions>(options: T): Promise<Notification<T>> {\n  // Most validation logic is handled on the provider, but need an early check here\n  // as we call date.valueOf when converting into a CreatePayload\n  if (typeof options !== 'object' || options === null) {\n    throw new Error(\n      'Invalid argument passed to create: argument must be an object and must not be null'\n    );\n  }\n\n  if (options.date !== undefined && !(options.date instanceof Date)) {\n    throw new Error('Invalid argument passed to create: \"date\" must be a valid Date object');\n  }\n\n  if (\n    options.expires !== undefined &&\n    options.expires !== null &&\n    !(options.expires instanceof Date)\n  ) {\n    throw new Error(\n      'Invalid argument passed to create: \"expires\" must be null or a valid Date object'\n    );\n  }\n\n  const response = await tryServiceDispatch(APITopic.CREATE_NOTIFICATION, {\n    ...options,\n    date: options.date && options.date.valueOf(),\n    expires: options.expires && options.expires.valueOf(),\n  } as CreatePayload);\n  return ({\n    ...response,\n    date: new Date(response.date),\n    expires: response.expires !== null ? new Date(response.expires) : null,\n  } as unknown) as Notification<T>;\n}\n\n/**\n * Clears a specific notification from the Notification Center.\n *\n * Returns true if the notification was successfully cleared.  Returns false if the notification was not cleared, without errors.\n *\n * ```ts\n * import {clear} from 'openfin-notifications';\n *\n * clear('uniqueNotificationId');\n * ```\n *\n * @param id ID of the notification to clear.\n */\nexport async function clear(id: string): Promise<boolean> {\n  // Should have some sort of input validation here...\n  return tryServiceDispatch(APITopic.CLEAR_NOTIFICATION, { id });\n}\n\n/**\n * Retrieves all Notifications which were created by the calling application, including child windows.\n *\n * ```ts\n * import {getAll} from 'openfin-notifications'\n *\n * getAll().then((notifications: Notification[]) => {\n *     console.log(`Service has ${notifications.length} notifications for this app:`, notifications);\n * });\n * ```\n *\n * There is deliberately no mechanism provided for fetching notifications that were created by a different application.\n */\nexport async function getAll(): Promise<Notification[]> {\n  // Should have some sort of input validation here...\n  const response = await tryServiceDispatch(APITopic.GET_APP_NOTIFICATIONS, undefined);\n  return response.map((note) => {\n    return {\n      ...note,\n      indicator: note.indicator || null,\n      date: new Date(note.date),\n      expires: note.expires !== null ? new Date(note.expires) : null,\n    };\n  });\n}\n\n/**\n * Clears all Notifications which were created by the calling application, including child windows.\n *\n * Returns the number of successfully cleared Notifications.\n *\n * ```ts\n * import {clearAll} from 'openfin-notifications';\n *\n * clearAll();\n * ```\n */\nexport async function clearAll(): Promise<number> {\n  // Should have some sort of input validation here...\n  return tryServiceDispatch(APITopic.CLEAR_APP_NOTIFICATIONS, undefined);\n}\n\n/**\n * Toggles the visibility of the Notification Center.\n *\n * ```ts\n * import {toggleNotificationCenter} from 'openfin-notifications';\n *\n * toggleNotificationCenter();\n * ```\n */\nexport async function toggleNotificationCenter(): Promise<void> {\n  return tryServiceDispatch(APITopic.TOGGLE_NOTIFICATION_CENTER, undefined);\n}\n\n/**\n * Get the total count of notifications from **all** applications.\n *\n * ```ts\n * import {getNotificationsCount} from 'openfin-notifications';\n *\n * getNotificationsCount();\n * ```\n */\nexport async function getNotificationsCount(): Promise<number> {\n  return tryServiceDispatch(APITopic.GET_NOTIFICATIONS_COUNT, undefined);\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst DeferredPromise_1 = require(\"./DeferredPromise\");\nasync function serialForEach(arr, asyncF) {\n    let i = 0;\n    for (const x of arr) {\n        await asyncF(x, i, arr);\n        i++;\n    }\n}\nexports.serialForEach = serialForEach;\nasync function serialMap(arr, asyncF) {\n    const result = [];\n    await serialForEach(arr, async (x, i, r) => {\n        result.push(await asyncF(x, i, r));\n    });\n    return result;\n}\nexports.serialMap = serialMap;\nasync function serialFilter(arr, asyncF) {\n    const result = [];\n    await serialForEach(arr, async (x, i, r) => {\n        if (await asyncF(x, i, r)) {\n            result.push(x);\n        }\n    });\n    return result;\n}\nexports.serialFilter = serialFilter;\nasync function parallelForEach(arr, asyncF) {\n    await Promise.all(arr.map(asyncF));\n}\nexports.parallelForEach = parallelForEach;\nasync function parallelMap(arr, asyncF) {\n    const result = [];\n    await parallelForEach(arr, async (x, i, r) => {\n        result[i] = await asyncF(x, i, r);\n    });\n    return result;\n}\nexports.parallelMap = parallelMap;\nasync function parallelFilter(arr, asyncF) {\n    const table = [];\n    await parallelForEach(arr, async (x, i, r) => {\n        table[i] = await asyncF(x, i, r);\n    });\n    return arr.filter((x, i) => table[i]);\n}\nexports.parallelFilter = parallelFilter;\n/**\n * Races a given promise against a timeout, and either resolves to the value the the promise resolved it, if it resolved before the\n * timeout, or rejects.\n *\n * @param timeoutMs Timeout period in ms\n * @param promise Promise to race against the timeout\n */\nfunction withStrictTimeout(timeoutMs, promise, rejectMessage) {\n    const timeout = new Promise((res, rej) => setTimeout(() => rej(new Error(rejectMessage)), timeoutMs));\n    return allowReject(Promise.race([timeout, promise]));\n}\nexports.withStrictTimeout = withStrictTimeout;\n/**\n * Races a given promise against a timeout, and resolves to a `[didTimeout, value?]` tuple indicating\n * whether the timeout occurred, and the value the promise resolved to (if timeout didn't occur).\n *\n * @param timeoutMs Timeout period in ms\n * @param promise Promise to race against the timeout\n */\nfunction withTimeout(timeoutMs, promise) {\n    const timeout = new Promise((res) => setTimeout(() => res([true, undefined]), timeoutMs));\n    const p = promise.then((value) => [false, value]);\n    return Promise.race([timeout, p]);\n}\nexports.withTimeout = withTimeout;\n/**\n * Returns a promise that resolves when the given predicate is true, evaluated immediately and each time the provided signal is fired.\n *\n * @param signal When this signal is fired, the predicate is revaluated\n * @param predicate The predicate to evaluate\n * @param guard A promise. If this rejects, give up listening to the signal and reject\n */\nfunction untilTrue(signal, predicate, guard) {\n    if (predicate()) {\n        return Promise.resolve();\n    }\n    return untilSignal(signal, predicate, guard);\n}\nexports.untilTrue = untilTrue;\n/**\n * Returns a promise that resolves when the given signal is fired, and the given predicate evaluates to true when passed the arguments\n * recevied from the signal.\n *\n * @param signal The signal to listen to\n * @param predicate The predicate to evaluate against arguments received from the signal\n * @param guard A promise. If this rejects, give up listening to the signal and reject\n */\nfunction untilSignal(signal, predicate, guard) {\n    const promise = new DeferredPromise_1.DeferredPromise();\n    const slot = signal.add((...args) => {\n        if (predicate(...args)) {\n            slot.remove();\n            promise.resolve();\n        }\n    });\n    if (guard) {\n        guard.catch((e) => {\n            slot.remove();\n            promise.reject(e);\n        });\n    }\n    return allowReject(promise.promise);\n}\nexports.untilSignal = untilSignal;\n/**\n * Attaches an empty `catch` block to a promise, then returns the original promise. This prevents rejection of the promise being logged as\n * a warning during tests, but does not otherwise change behaviour should the promise reject. This should be called for promises we expect\n * to reject under normal circumstances, but would not otherwise have a `catch` block attached.\n *\n * @param promise The promise to attach the catch block to\n */\nfunction allowReject(promise) {\n    promise.catch(() => { });\n    return promise;\n}\nexports.allowReject = allowReject;\n","/**\n * @hidden\n */\n\n/**\n * Acts as a central point for routing all events received from the provider.\n */\nimport { EventEmitter } from 'events';\n\nimport { TransportMappings, TransportMemberMappings } from './internal';\n\nexport interface EventSpecification {\n  type: string;\n}\n\ntype EmitterProvider = (targetId: string) => EventEmitter;\ntype EventDeserializer<E extends EventSpecification, T extends E> = (event: Transport<T>) => T;\n\ninterface EventTarget {\n  type: string;\n  id: string;\n}\nexport type Targeted<T extends EventSpecification> = T & {\n  /**\n   * Indicates which emitter the client should use to dispatch this event.\n   *\n   * Allows events to be raised from client-side objects that mirror a corresponding provider-side object. If there\n   * is no such model of client-side objects, pass `default` to emit the event from a shared top-level/\"global\" event\n   * emitter.\n   */\n  target: EventTarget | 'default';\n};\nexport type Transport<T extends EventSpecification> = TransportMappings<T> extends never\n  ? {\n      [K in keyof T]: TransportMemberMappings<T[K]>;\n    }\n  : TransportMappings<T>;\n\n/**\n * Class for helping take events that have arrived at the client via the IAB channel, and dispatching them on the correct client-side object\n */\nexport class EventRouter<E extends EventSpecification> {\n  private readonly _emitterProviders: { [targetType: string]: (targetId: string) => EventEmitter };\n  private readonly _deserializers: { [eventType: string]: EventDeserializer<E, E> };\n\n  private readonly _defaultEmitter: EventEmitter;\n\n  public constructor(defaultEmitter: EventEmitter) {\n    this._emitterProviders = {};\n    this._deserializers = {};\n\n    this._defaultEmitter = defaultEmitter;\n  }\n\n  public registerEmitterProvider(targetType: string, emitterProvider: EmitterProvider): void {\n    this._emitterProviders[targetType] = emitterProvider;\n  }\n\n  public registerDeserializer<T extends E>(\n    eventType: T['type'],\n    deserializer: EventDeserializer<E, T>\n  ): void {\n    this._deserializers[eventType] = (deserializer as unknown) as EventDeserializer<E, E>;\n  }\n\n  public dispatchEvent<T extends E>(event: Targeted<Transport<T>>): void {\n    const { type, target, ...rest } = event;\n\n    let emitter: EventEmitter;\n    if (!target) {\n      throw new Error('Invalid event, no target specified');\n    } else if (target === 'default') {\n      emitter = this._defaultEmitter;\n    } else if (this._emitterProviders[target.type]) {\n      emitter = this._emitterProviders[target.type](target.id);\n    } else {\n      throw new Error(`Invalid target, no provider registered for '${target.type}'`);\n    }\n\n    // Need to remove 'target' from event before emitting event\n    const inputEvent: Transport<T> = ({ type, ...rest } as unknown) as Transport<T>;\n\n    // Also run through any custom deserializer\n    const deserializer = this._deserializers[type];\n    if (deserializer) {\n      emitter.emit(type, deserializer(inputEvent));\n    } else {\n      emitter.emit(type, inputEvent);\n    }\n  }\n}\n","/**\n * @module Provider\n */\n\n/**\n * Need a comment block here so that the comment block above is interpreted as a file comment, and not a comment on the\n * import below.\n *\n * @hidden\n */\nimport semverCompare from 'semver-compare';\nimport { withStrictTimeout } from 'openfin-service-async';\n\nimport { tryServiceDispatch } from './connection';\nimport { APITopic } from './internal';\n\n/**\n * Status object returned by the Provider.\n */\nexport interface ProviderStatus {\n  /**\n   * The current connection status from the Client to the Provider.\n   */\n  connected: boolean;\n\n  /**\n   * The version number of the Provider. If the Provider is not connected, this will be `null`.\n   */\n  version: string | null;\n}\n\n/**\n * Retrieves the connection status and version semver of the Service Provider in the shape of a {@link ProviderStatus} object.\n *\n * If the Provider is connected, its' version number will be supplied in the returned object. If not, `version` will be `null`.\n *\n * ```ts\n * import {provider} from 'openfin-notifications';\n *\n * const status: ProviderStatus = provider.getStatus();\n * console.log(status.connected ? `Conencted to provider (version ${status.version})` : 'Not connected to provider');\n * ```\n *\n * Note: Connection status is only available when the connected provider is verison 0.11.2 or later. For earlier\n * versions, this API will indicate that the provider is disconnected.\n *\n * @since 0.11.2\n */\nexport function getStatus(): Promise<ProviderStatus> {\n  // We need to race a timeout here as we never reject if the provider is not connected.\n  return withStrictTimeout(\n    500,\n    tryServiceDispatch(APITopic.GET_PROVIDER_STATUS, undefined),\n    ''\n  ).catch(() => {\n    return {\n      connected: false,\n      version: null,\n    };\n  });\n}\n\n/**\n * Evaluates the provided version against the Providers version.\n *\n * This will return `true` if the Provider version is greater than or equal to the provided version. If not, `false` will be returned.\n *\n * If the Provider is not connected, `false` will be returned.\n *\n * ```ts\n * import {provider, VERSION} from 'openfin-notifications';\n *\n * const hasMatchingProvider: boolean = provider.isConnectedToAtLeast(VERSION);\n * if (!hasMatchingProvider) {\n *     console.warn('Connected to an older provider version. Some functionality may not be available.');\n * }\n * ```\n *\n * Note: Version information is only available when the connected provider is verison 0.11.2 or later. For earlier\n * versions, this API will indicate that the provider is disconnected.\n *\n * @param version Version to compare against the Provider version. This should be in semvar format.\n * @since 0.11.2\n */\nexport async function isConnectedToAtLeast(version: string): Promise<boolean> {\n  const status = await getStatus();\n\n  if (status.connected && status.version !== null) {\n    const compare = semverCompare(status.version, version);\n\n    if (compare === 0 || compare === 1) {\n      return true;\n    }\n  }\n\n  return false;\n}\n","module.exports = function cmp (a, b) {\n    var pa = a.split('.');\n    var pb = b.split('.');\n    for (var i = 0; i < 3; i++) {\n        var na = Number(pa[i]);\n        var nb = Number(pb[i]);\n        if (na > nb) return 1;\n        if (nb > na) return -1;\n        if (!isNaN(na) && isNaN(nb)) return 1;\n        if (isNaN(na) && !isNaN(nb)) return -1;\n    }\n    return 0;\n};\n","/**\n * @hidden\n */\n/**\n * Need a comment block here so that the comment block above is interpreted as a file comment, and not a comment on the\n * import below.\n *\n * @hidden\n */\nimport { Events } from './internal';\n\n/**\n * Validates and returns the provided function\n */\nexport function sanitizeFunction<T, U extends any[]>(value: (...args: U) => T): (...args: U) => T {\n  if (typeof value !== 'function') {\n    throw new Error(\n      `Invalid argument passed: ${safeStringify(\n        value,\n        'The provided value'\n      )} is not a valid function`\n    );\n  }\n\n  return value;\n}\n\n/**\n * Validates the provided event type\n */\nexport function sanitizeEventType<E extends Events>(eventType: E['type']): E['type'] {\n  if (\n    eventType === 'notification-action' ||\n    eventType === 'notification-created' ||\n    eventType === 'notification-closed' ||\n    eventType === 'notifications-count-changed' ||\n    eventType === 'notification-form-submitted'\n  ) {\n    return eventType;\n  }\n\n  throw new Error(\n    `Invalid argument passed: ${safeStringify(\n      eventType,\n      'The provided event type'\n    )} is not a valid Notifications event type`\n  );\n}\n\n/**\n * Validates we're running inside an OpenFin environment\n */\nexport function validateEnvironment(): void {\n  if (typeof fin === 'undefined') {\n    throw new Error(\n      'fin is not defined. The openfin-notifications module is only intended for use in an OpenFin application.'\n    );\n  }\n}\n\nexport function safeStringify(value: unknown, fallback: string): string {\n  // Provided object may not be stringify-able (e.g., due to circular references), so we need to try-catch\n  let result: string;\n  try {\n    result = JSON.stringify(value);\n  } catch (e) {\n    result = fallback;\n  }\n\n  return result;\n}\n","/**\n * @module Notifications\n */\n\n/**\n * Lists possible semantic use-cases for notifications, which can alter how the notification is presented to the user.\n *\n * Additional indicator types may be added in future releases.\n */\nexport enum IndicatorType {\n  FAILURE = 'failure',\n  WARNING = 'warning',\n  SUCCESS = 'success',\n}\n\nexport interface NotificationIndicator {\n  /**\n   * Indicates the semantic intent behind the indicator - this determines the visual styling of the indicator when\n   * seen by the user.\n   *\n   * For example - an indicator could be used to:\n   * - `IndicatorType.FAILURE`: Indicate a failure has occurred from an action the user has taken.\n   * - `IndicatorType.WARNING`: Warn a user that they have a limited amount of time to buy.\n   * - `IndicatorType.SUCCESS`: Inform the user that an item has been successfully ordered.\n   */\n  type: IndicatorType;\n\n  /**\n   * Customized text to be displayed in the indicator. When set, this will override the default indicator text.\n   * Text is limited to 32 characters including spaces.\n   */\n  text?: string;\n}\n","/**\n * Notifications allow additional UI components to be specified by applications. The service will control the\n * positioning and styling of these components.\n *\n * In this version of the service, only buttons are supported. Additional control types will be added in future\n * releases.\n *\n * @module Controls\n */\n\n/**\n * Need a comment block here so that the comment block above is interpreted as a file comment, and not a comment on the\n * import below.\n *\n * @hidden\n */\nimport { ActionDeclaration } from './actions';\n\n/**\n * Helper to make the `type` field required on any type that defines it as being optional.\n */\ntype WithExplicitType<T extends { type?: string }> = T & { type: string };\n\n/**\n * *Not yet implemented*\n *\n * Union of the options objects of all \"primary control\" components supported by the service.\n */\nexport type PrimaryControlOptions = never;\n\n/**\n * Union of options objects of all components that can be added to a notification, includes both buttons and primary\n * controls.\n */\nexport type ControlOptions = PrimaryControlOptions | WithExplicitType<ButtonOptions>;\n\n/**\n * Configuration options for constructing a button within a notification.\n */\nexport interface ButtonOptions {\n  /**\n   * Identifies the type of this control. Additional control types will be added in future versions of the service.\n   *\n   * This type declaration is optional, as the other control types will be declared in a slightly different way.\n   * Whilst this field is optional when specifiying options, it will be added by the service during creation (see\n   * {@link create}) - meaning it will always be present when receiving a `notification-action` event from a button.\n   */\n  type?: 'button';\n\n  /**\n   * User-facing button text.\n   *\n   * The button caption should be kept short, particularly if there are multiple buttons. Notifications are\n   * fixed-width, and all buttons will be displayed on the same row.\n   */\n  title: string;\n\n  /**\n   * Indicates that this button will be visually displayed as a 'Call to Action' button. In this case a Call To Action\n   * means the button is made more prominent. We recommend you use this for true calls to action. For example, if you\n   * have a notification which contains a report, it might have an 'OK' button which takes you to the report, and a\n   * 'Dismiss' button which simply closes the notification. We suggest you make only the 'OK' button a CTA here.'\n   *\n   * If set as `false` or `undefined`, the default simple text button will be used instead.\n   */\n  cta?: boolean;\n\n  /**\n   * Indicates that this button should submit a form.\n   * If a form is invalid, based on your validation rules provided, the button will be disabled until the users input within the form is valid.\n   */\n  submit?: boolean;\n\n  /**\n   * Optional icon URL, if an icon should be placed on the button.\n   *\n   * Icons are placed to the left of the button text.\n   */\n  iconUrl?: string;\n\n  /**\n   * Defines the data to be passed back to the application when the button is clicked.\n   *\n   * The {@link NotificationActionResult} specified here will be returned to the application via a\n   * `notification-action` event when the button is clicked.\n   *\n   * If omitted or `null`, applications will not receive a {@link NotificationActionEvent|`notification-action`}\n   * event when the button is clicked. This may be appropriate if the button represents a \"dismiss\" or some other\n   * side-effect-free interaction. Even if `onClick` is omitted or `null`, a `notification-closed` event will still be\n   * raised after the button click.\n   *\n   * Future versions of the service will allow for greater control over what happens when a button is clicked.\n   */\n  onClick?: ActionDeclaration<never, never> | null;\n\n  /**\n   * Button index used for events. This gets set when hydrating.\n   *\n   * @hidden\n   */\n  index?: number;\n}\n","/**\n * @hidden\n */\n\n/**\n * Need a comment block here so that the comment block above is interpreted as a file comment, and not a comment on the\n * import below.\n *\n * @hidden\n */\nimport { Identity } from 'openfin/_v2/main';\n\n/**\n * For notifications that have originated from an application running on the same machine as the provider.\n */\nexport interface NotificationSourceDesktop {\n  type: 'desktop';\n\n  /**\n   * The identity of the window that raised this notification.\n   *\n   * This will always be a window of the current application - but\n   * could be have been raised by an instance of this application\n   * running on a different machine.\n   */\n  identity: Identity;\n}\n\n/**\n * Union of all possible notification sources.\n */\nexport type NotificationSource = NotificationSourceDesktop;\n","export * from './fields';\nexport * from './widgets';\n","/**\n * When you make a form, you provide a list of [[FormFields]]. Each FormField contains the ingredients to make a single widget in the form.\n * The actual definitions of the widgets are derived from [[BaseWidgetSpec]].\n *\n * A FormField contains the type of data, the key to store the user input into [[CustomDataWithForms]], and some additional configuration.\n * @module FormFields\n */\n\n/**\n * imports.\n */\nimport { StringWidget, NumberWidget, BooleanWidget } from './widgets';\n\n/**\n * Data type of a fields. e.g. string, number\n */\nexport const FieldType = {\n  string: 'string',\n  number: 'number',\n  boolean: 'boolean',\n  // date = \"date\"\n} as const;\n\n/**\n * An abstract validation entry.\n */\nexport interface ValidationEntry<T = any> {\n  /**\n   * Message displayed to the user when input is invalid.\n   */\n  invalidMessage?: string;\n  /**\n   * Validation argument to test against.\n   */\n  arg?: T;\n}\n\n/**\n * The base type for form fields.\n */\nexport interface BaseField<T extends keyof typeof FieldType, D = unknown> {\n  /**\n   * Field data type.\n   */\n  type: T;\n  /**\n   * The property key that this field value will appear in the returned {@link NotificationFormSubmittedEvent.form|form} object.\n   */\n  key: string;\n  /**\n   * Default value for field, and where it will be written to\n   */\n  value?: D;\n  /**\n   * Validation rules used to validate user input.\n   */\n  validation?: Record<string, any>;\n  /**\n   * Input label.\n   */\n  label?: string;\n}\n\n/**\n * String field within a form.\n */\nexport interface StringField<W extends StringWidget = StringWidget>\n  extends BaseField<'string', string> {\n  validation?: Partial<{\n    /**\n     * Minimum number of characters.\n     */\n    min: ValidationEntry<number>;\n    /**\n     * Maximum number of characters.\n     */\n    max: ValidationEntry<number>;\n    /**\n     * Length of the input string.\n     */\n    length: ValidationEntry<number>;\n    /**\n     * The field is required to be filled in by the user.\n     */\n    required: ValidationEntry;\n    /**\n     * Provide a regex string that will be tested against the input value.\n     */\n    match: ValidationEntry<string>;\n  }>;\n  /**\n   * What input widget is used.\n   * @default StringWidgets {@link StringWidgets}\n   */\n  widget: W;\n}\n\n/**\n * Number field within a form.\n */\nexport interface NumberField<W extends NumberWidget = NumberWidget>\n  extends BaseField<'number', number> {\n  validation?: Partial<{\n    /**\n     * Minimum number of characters.\n     */\n    min: ValidationEntry<number>;\n    /**\n     * Maximum number of characters.\n     */\n    max: ValidationEntry<number>;\n    /**\n     * Number must be less than this.\n     */\n    lessThan: ValidationEntry<number>;\n    /**\n     * Number must be more than this.\n     */\n    moreThan: ValidationEntry<number>;\n    /**\n     * Number must be positive.\n     */\n    positive: ValidationEntry;\n    /**\n     * Number must be negative.\n     */\n    negative: ValidationEntry;\n    /**\n     * The field is required to be filled in by the user.\n     */\n    required: ValidationEntry;\n  }>;\n  widget: W;\n}\n\nexport interface BooleanField<W extends BooleanWidget = BooleanWidget>\n  extends BaseField<'boolean', boolean> {\n  widget: W;\n}\n\n/**\n * A field in a form.\n */\nexport type FormField = StringField | NumberField | BooleanField;\n\n/**\n * An ordered array of fields representing a form.\n * When the form is displayed to the user the fields will appear in the same order they are in the array.\n */\nexport type NotificationFormData = ReadonlyArray<FormField>;\n","/**\n * These are available widgets for use in forms.\n *\n * @module FormWidgets\n */\n\n// I have left commented out examples of other widget types to aid\n// others in implementing new widgets.\n\n/**\n * The StringWidgetType is how you display a text string.\n */\nexport const StringWidgetType = {\n  Text: 'Text',\n  // TextArea: 'TextArea',\n  // Color: 'Color'\n} as const;\n\nexport const NumberWidgetType = {\n  Number: 'Number',\n} as const;\n\nexport const BooleanWidgetType = {\n  Toggle: 'Toggle',\n\tCheckbox: 'Checkbox'\n} as const;\n\nexport const WidgetType = {\n  ...StringWidgetType,\n  ...NumberWidgetType,\n  ...BooleanWidgetType,\n} as const;\n\n/**\n * All available widgets.\n */\nexport type Widget = StringWidget | NumberWidget | BooleanWidget;\n\nexport interface BaseWidgetSpec<T extends keyof typeof WidgetType> {\n  /**\n   * The type of widget to be used. Widgets can only be used with matching specific data types.\n   * For example the `Text` widget can be used with the `string` field type.\n   */\n  type: T;\n}\n\n/**\n * A simple text field input widget.\n */\nexport interface TextWidgetSpec extends BaseWidgetSpec<typeof WidgetType['Text']> {\n  placeholder?: string;\n}\n\n/**\n * String field input widget.\n */\nexport type StringWidget = TextWidgetSpec;\n\nexport interface NumberWidgetSpec extends BaseWidgetSpec<typeof WidgetType['Number']> {\n  placeholder?: string;\n  min?: number;\n  max?: number;\n}\n\n/**\n * Number field input widget.\n */\nexport type NumberWidget = NumberWidgetSpec;\n\nexport type ToggleWidgetSpec = BaseWidgetSpec<typeof WidgetType['Toggle']>;\nexport type CheckboxWidgetSpec = BaseWidgetSpec<typeof WidgetType['Checkbox']>;\n\nexport type BooleanWidget = ToggleWidgetSpec | CheckboxWidgetSpec;\n\n// export interface MultiOption<T = unknown> {\n//     display?: string;\n//     value: T;\n// }\n\n// export interface SelectWidget<T = string | number> extends BaseWidget<typeof WidgetType['Select']> {\n//     options: MultiOption<T>[];\n//     placeholder?: string;\n// }\n\n// export interface RadioButtonGroupWidget extends BaseWidget<typeof WidgetType['RadioButtonGroup']> {\n//     options: MultiOption[];\n//     placeholder?: string;\n// }\n\n// export type MultiWidgets = SelectWidget | RadioButtonGroupWidget;\n","/**\n * @module Notifications\n */\n\n/**\n * Details of the application that will handle any actions coming from a particular stream.\n */\nexport interface NotificationStream {\n  /**\n   * Unique id of the stream.\n   */\n  id: string;\n\n  /**\n   * Stream title.\n   *\n   * Providing a different displayName for an existing stream id will update the\n   * displayName of the stream stored in Notification Center.\n   *\n   */\n  displayName: string;\n\n  /**\n   * ID of the application source of this stream.\n   */\n  appId: string;\n}\n","export * from './BaseNotificationOptions';\nexport * from './templates';\n","/**\n * Core notification features.\n *\n * @module BaseNotificationOptions\n */\n\n/**\n * imports\n */\nimport {\n  NotificationStream,\n  NotificationIndicator,\n  ButtonOptions,\n  ActionDeclaration,\n  ActionNoop,\n  CustomData,\n} from '..';\n\nimport { TemplateNames } from './templates';\n\n/**\n * Configuration options for constructing a Notifications object, shared between all templates.\n */\nexport interface BaseNotificationOptions<T extends keyof typeof TemplateNames> {\n  /**\n   * A unique identifier for the notification.\n   *\n   * If not provided at time of creation, one will be generated for you and returned as part of the {@link create} method.\n   */\n  id?: string;\n\n  /**\n   * **Experimental**\n   */\n  template: T;\n\n  /**\n   * Title of the notification.\n   *\n   * Displayed as the first line of the notification, in a heading style.\n   */\n  title: string;\n\n  /**\n   * Describes the context of this notification. Allows users to control different notification types that are raised\n   * by an application.\n   *\n   * This string is not displayed on the notification itself, but should be user-readable. It will be displayed in\n   * the Notification Center preferences section, and any string passed as a `category` should make sense when\n   * displayed in that context.\n   *\n   * Event categories should list all the different types of notifications raised by your app. As a general guide, if\n   * a user may want to have different preferences for some subset of notifications created by your app, then\n   * applications should ensure that those notifications have a distinct category.\n   *\n   * For example - given a calendar app, notification categories could be:\n   * - `'Upcoming Events'`: Notification that an event is about to start\n   * - `'Event Start'`: Notification raised when event starts, expiring at the event end time\n   * - `'Event Modified'`: When an event is modified\n   * - `'Event Cancelled'`: When an event is cancelled\n   * - `'Event Response'`: An attendee has responded to an event invitation that you created\n   * - `'Daily Agenda'`: A notification sent each morning with event reminders\n   *\n   * **NOTE:** The user-facing UI that a user would use to manage their preferences is still in progress. This\n   * property has been added in advance of this UI being released, to ensure future compatibility.\n   */\n  category: string;\n\n  /**\n   * Add a semantic visual indicator to a notification, to signal to the user the nature of the event that they are\n   * being notified about.\n   *\n   * This should not be treated as a priority.\n   */\n  indicator?: NotificationIndicator | null;\n\n  /**\n   * URL of the icon to be displayed in the notification.\n   */\n  icon?: string;\n\n  /**\n   * Application-defined context data that can be attached to buttons on notifications.\n   *\n   * When using forms, form data submitted will be written to `customData` and returned to your app by\n   * listening to the submit {@link NotificationActionEvent|`notification-action`} with the trigger {@link ActionTrigger.SUBMIT|submit}.\n   */\n  customData?: CustomData;\n\n  /**\n   * The timestamp shown on the notification. If omitted, the current date/time will be used.\n   *\n   * This is presentational only - a future date will not incur a scheduling action.\n   */\n  date?: Date;\n\n  /**\n   * The expiry date and time of the notification. If specified, the notification will be removed at this time, or as\n   * soon as possible after. If not specified, the notification will never expire, and will persist until it\n   * is closed.\n   */\n  expires?: Date | null;\n\n  /**\n   * When set to `sticky` this settings enables the notification toast to stay visible on the desktop\n   * until the user interacts with it. When set to `transient` the toasts will follow the default behavior\n   * of fading away after a short duration\n   *\n   * The default value is `transient`.\n   */\n  sticky?: 'sticky' | 'transient';\n\n  /**\n   * A list of buttons to display below the notification text.\n   *\n   * Notifications support up to four buttons. Attempting to add more than four will result in the notification\n   * being rejected by the service.\n   */\n  buttons?: ButtonOptions[];\n\n  /**\n   * Notification stream\n   *\n   * If the application belongs to a stream, the user interaction with the notification will be handled\n   * by the stream application defined in notification stream.\n   */\n  stream?: NotificationStream | null;\n\n  /**\n   * An {@link NotificationActionResult|action result} to be passed back to the application inside the\n   * {@link NotificationActionEvent|`notification-action`} event fired when the notification is clicked.\n   *\n   * This action will only be raised on clicks to the notification body. Interactions with buttons (both\n   * application-defined buttons, and the default 'X' close button) will not trigger a\n   * {@link ActionTrigger.SELECT|select} action.\n   *\n   * See {@link Actions} for more details on notification actions, and receiving action events from notifications.\n   */\n  onSelect?: (ActionDeclaration<never, never> & ActionNoop) | null;\n\n  /**\n   * An {@link NotificationActionResult|action result} to be passed back to the application inside the\n   * {@link NotificationActionEvent|`notification-action`} event fired when the notification the expires.\n   *\n   * If `expires` is specified for the notification, this action will be raised when the notification expires. If\n   * `expires` is not specified for the notification, this action will never be raised. Note that if an `onClose`\n   * action result is also specified, both actions will be raised if and when the notification expires.\n   *\n   * See {@link Actions} for more details on notification actions, and receiving action events from notifications.\n   */\n  onExpire?: ActionDeclaration<never, never> | null;\n\n  /**\n   * An {@link NotificationActionResult|action result} to be passed back to the application inside the\n   * {@link NotificationActionEvent|`notification-action`} event fired when the notification is closed.\n   *\n   * This action will be raised regardless of how the notification is closed. This can be from user interaction\n   * (until future revisions allow default click behaviour to be overriden, this will be any click anywhere within\n   * the notification), the notification expiring, or from the notification being programmaticially removed, such as\n   * a call to `clear`.\n   *\n   * See {@link Actions} for more details on notification actions, and receiving action events from notifications.\n   */\n  onClose?: ActionDeclaration<never, never> | null;\n}\n"],"sourceRoot":""}