/**
 * @module NotificationCenter
 */
/**
 * Need a comment block here so that the comment block above is interpreted as a file comment, and not a comment on the
 * import below.
 *
 * @hidden
 */
import { NotificationActionResult, ActionTrigger } from './actions';
import { ButtonOptions, ControlOptions } from './controls';
import { DistributiveOmit } from './internal';
import * as provider from './provider';
import { NotificationSource } from './source';
import { NotificationIndicator, IndicatorType } from './indicator';
import { NotificationOptions } from './templates/templates';
export * from './actions';
export * from './controls';
export * from './source';
export * from './forms';
export * from './stream';
export * from './templates';
export { provider, NotificationOptions };
export { NotificationIndicator, IndicatorType as NotificationIndicatorType };
/**
 * The Notification Client library's version in semver format.
 *
 * This is the version which you are currently using.
 */
export declare const VERSION: string;
/**
 * Application-defined context data that can be attached to buttons on notifications.
 */
export declare type CustomData = Record<string, any>;
/**
 * A fully-hydrated form of {@link NotificationOptions}.
 *
 * After {@link create|creating} a notification, the service will return an object of this type. This will be the given
 * options object, with any unspecified fields filled-in with default values.
 *
 * This object should be treated as immutable. Modifying its state will not have any effect on the notification or the
 * state of the service.
 */
export declare type Notification<T extends NotificationOptions = NotificationOptions> = Readonly<Required<DistributiveOmit<T, 'buttons'>> & {
    readonly buttons: ReadonlyArray<Required<ButtonOptions>>;
}>;
/**
 * Event fired when an action is raised for a notification due to a specified trigger. It is important to note that
 * applications will only receive these events if they indicate to the service that they want to receive these events.
 * See {@link Actions} for a full example of how actions are defined, and how an application can listen to and handle
 * them.
 *
 * This can be fired due to interaction with notification buttons or the notification itself, the notification being
 * closed (either by user interaction or by API call), or by the notification expiring. Later versions of the service
 * will add additional control types that may raise actions from user interaction. All actions, for all control types,
 * will be returned to the application via the same `notification-action` event type.
 *
 * The event object will contain the application-defined {@link NotificationActionResult|metadata} that allowed this
 * action to be raised, and details on what triggered this action and which control the user interacted with.
 *
 * Unlike other event types, `notification-action` events will be buffered by the service until the application has
 * added a listener for this event type, at which point it will receive all buffered `notification-action` events. The
 * service will also attempt to restart the application if it is not running when the event is fired.
 *
 * This type includes a generic type argument, should applications wish to define their own interface for action
 * results. See {@link NotificationActionResult} for details.
 *
 * @event "notification-action"
 */
export interface NotificationActionEvent<T = CustomData> {
    type: 'notification-action';
    /**
     * The notification that created this action
     */
    notification: Readonly<Notification>;
    /**
     * This property allows the application handling the action to identify where this notification originated.
     */
    source: NotificationSource;
    /**
     * Indicates what triggered this action.
     *
     * Note that the `programmatic` trigger is not yet implemented.
     */
    trigger: ActionTrigger;
    /**
     * The control whose interaction resulted in this action being raised. Will only be present when {@link trigger} is
     * {@link ActionTrigger.CONTROL}.
     *
     * Future versions of the service will add additional controls beyond buttons, and interactions with these new
     * control types will also come through this one event type. For best forward-compatibility, applications should
     * always check the `type` property of this control, and not assume that the type will always be `'button'`.
     *
     * This field is marked optional as future versions of the service will also include alternate methods of raising
     * `notification-action` events that do not originate from a button or other control.
     *
     * When present, the object here will always be strictly equal to one of the control definitions within
     * `notification`. This means `indexOf` checks and other equality checks can be performed on this field if
     * required, such as:
     *
     * ```ts
     * function onNotificationAction(event: NotificationActionEvent): void {
     *     if (event.control && event.control.type === 'button') {
     *         const butttonIndex = event.notification.buttons.indexOf(event.control);
     *
     *         // Handle button click
     *         // . . .
     *     }
     * }
     * ```
     */
    control?: Readonly<Required<ControlOptions>>;
    /**
     * Application-defined metadata that this event is passing back to the application.
     *
     * A `notification-action` event is only fired for a given trigger if the
     * {@link NotificationOptions|notification options} included an action result for that trigger.
     *
     * See the comment on the {@link NotificationActionEvent} type for an example of buttons that do and don't raise
     * actions.
     */
    result: NotificationActionResult<T>;
}
/**
 * Event fired whenever the notification has been closed.
 *
 * This event is fired regardless of how the notification was closed - i.e.: via a call to `clear`/`clearAll`, the
 * notification expiring, or by a user clicking either the notification itself, the notification's close button, or
 * a button on the notification.
 *
 * @event "notification-closed"
 */
export interface NotificationClosedEvent {
    type: 'notification-closed';
    /**
     * The notification that has just been closed.
     *
     * This object will match what is returned from the `create` call when the notification was first created.
     */
    notification: Notification;
}
/**
 * Event fired whenever a new notification has been created.
 *
 * @event "notification-created"
 */
export interface NotificationCreatedEvent {
    type: 'notification-created';
    /**
     * The notification that has just been created.
     *
     * This object will match what is returned from the `create` call.
     */
    notification: Notification;
}
/**
 * Event fired whenever the total number of notifications from **all** sources changes.
 *
 * @event "notifications-count-changed"
 */
export interface NotificationsCountChanged {
    type: 'notifications-count-changed';
    /**
     * Number of notifications in the Center.
     */
    count: number;
}
export interface NotificationFormSubmittedEvent {
    type: 'notification-form-submitted';
    notification: Notification;
    form: Record<string, unknown>;
}
export declare function addEventListener(eventType: 'notification-form-submitted', listener: (event: NotificationFormSubmittedEvent) => void): void;
export declare function addEventListener(eventType: 'notification-action', listener: (event: NotificationActionEvent) => void): void;
export declare function addEventListener(eventType: 'notification-created', listener: (event: NotificationCreatedEvent) => void): void;
export declare function addEventListener(eventType: 'notification-closed', listener: (event: NotificationClosedEvent) => void): void;
export declare function addEventListener(eventType: 'notifications-count-changed', listener: (event: NotificationsCountChanged) => void): void;
export declare function removeEventListener(eventType: 'notification-form-submitted', listener: (event: NotificationFormSubmittedEvent) => void): void;
export declare function removeEventListener(eventType: 'notification-action', listener: (event: NotificationActionEvent) => void): void;
export declare function removeEventListener(eventType: 'notification-created', listener: (event: NotificationCreatedEvent) => void): void;
export declare function removeEventListener(eventType: 'notification-closed', listener: (event: NotificationClosedEvent) => void): void;
export declare function removeEventListener(eventType: 'notifications-count-changed', listener: (event: NotificationsCountChanged) => void): void;
/**
 * Creates a new notification.
 *
 * The notification will appear in the Notification Center and as a toast if the Center is not visible.
 *
 * If a notification is created with an `id` of an already existing notification, the existing notification will be recreated with the new content.
 *
 * ```ts
 * import {create} from 'openfin-notifications';
 *
 * create({
 *      id: 'uniqueNotificationId',
 *      title: 'Notification Title',
 *      body: 'Text to display within the notification body',
 *      category: 'Sample Notifications',
 *      icon: 'https://openfin.co/favicon.ico'
 * });
 * ```
 *
 * @param options Notification configuration options.
 */
export declare function create<T extends NotificationOptions>(options: T): Promise<Notification<T>>;
/**
 * Clears a specific notification from the Notification Center.
 *
 * Returns true if the notification was successfully cleared.  Returns false if the notification was not cleared, without errors.
 *
 * ```ts
 * import {clear} from 'openfin-notifications';
 *
 * clear('uniqueNotificationId');
 * ```
 *
 * @param id ID of the notification to clear.
 */
export declare function clear(id: string): Promise<boolean>;
/**
 * Retrieves all Notifications which were created by the calling application, including child windows.
 *
 * ```ts
 * import {getAll} from 'openfin-notifications'
 *
 * getAll().then((notifications: Notification[]) => {
 *     console.log(`Service has ${notifications.length} notifications for this app:`, notifications);
 * });
 * ```
 *
 * There is deliberately no mechanism provided for fetching notifications that were created by a different application.
 */
export declare function getAll(): Promise<Notification[]>;
/**
 * Clears all Notifications which were created by the calling application, including child windows.
 *
 * Returns the number of successfully cleared Notifications.
 *
 * ```ts
 * import {clearAll} from 'openfin-notifications';
 *
 * clearAll();
 * ```
 */
export declare function clearAll(): Promise<number>;
/**
 * Toggles the visibility of the Notification Center.
 *
 * ```ts
 * import {toggleNotificationCenter} from 'openfin-notifications';
 *
 * toggleNotificationCenter();
 * ```
 */
export declare function toggleNotificationCenter(): Promise<void>;
/**
 * Get the total count of notifications from **all** applications.
 *
 * ```ts
 * import {getNotificationsCount} from 'openfin-notifications';
 *
 * getNotificationsCount();
 * ```
 */
export declare function getNotificationsCount(): Promise<number>;
