(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["notifications"] = factory();
	else
		root["notifications"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 6);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @hidden
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.APITopic = exports.SERVICE_CHANNEL = exports.SERVICE_IDENTITY = void 0;
/**
 * The identity of the main application window of the service provider
 */
exports.SERVICE_IDENTITY = {
    uuid: 'notifications-service',
    name: 'notifications-service',
};
/**
 * Name of the IAB channel use to communicate between client and provider
 */
exports.SERVICE_CHANNEL = 'of-notifications-service-v1';
var APITopic;
(function (APITopic) {
    APITopic["CREATE_NOTIFICATION"] = "create-notification";
    APITopic["CLEAR_NOTIFICATION"] = "clear-notification";
    APITopic["GET_APP_NOTIFICATIONS"] = "fetch-app-notifications";
    APITopic["CLEAR_APP_NOTIFICATIONS"] = "clear-app-notifications";
    APITopic["TOGGLE_NOTIFICATION_CENTER"] = "toggle-notification-center";
    APITopic["ADD_EVENT_LISTENER"] = "add-event-listener";
    APITopic["REMOVE_EVENT_LISTENER"] = "remove-event-listener";
    APITopic["GET_PROVIDER_STATUS"] = "get-provider-status";
    APITopic["GET_NOTIFICATIONS_COUNT"] = "get-notifications-count";
})(APITopic = exports.APITopic || (exports.APITopic = {}));


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Actions are the mechanism through which notifications send messages back to the application that created them. The
 * service defines a number of ways in which actions can be raised (a notification being interacted with by the user,
 * being closed, expiring, etc.), and it is up to each application to decide if it wishes to be informed when each of
 * these triggers occur.
 *
 * For an action to be raised when one of these triggers occurs, the application must specify an
 * {@link NotificationActionResult|action result} for each trigger it is interested in. The application should then
 * listen for when these actions are raised by listening for the {@link NotificationActionEvent|`notification-action`}
 * event.
 *
 * This event is fired once each time an action is raised, and will contain the
 * {@link NotificationActionResult|action result} the application specified for that trigger. The application may then
 * use the {@link NotificationActionResult|action result} to determine which trigger occurred and respond appropriately.
 *
 * If an {@link NotificationActionResult|action result} is not specified for a particular trigger, or it is set to
 * `null`, the application will not receive a corresponding {@link NotificationActionEvent|`notification-action`} when
 * that trigger occurs.
 *
 * Unlike other event types, {@link NotificationActionEvent|`notification-action`} events will be buffered by the
 * service until the application has added a listener for this event type, at which point it will receive all buffered
 * {@link NotificationActionEvent|`notification-action`} events. The service will also attempt to restart the
 * application if it is not running when the event is fired.
 *
 * For an overview of actions, consider the sample notification below:
 * ```ts
 * import {addEventListener, create} from 'openfin-notifications';
 *
 * // Create a notification with two buttons
 * create({
 *     // Basic info
 *     title: 'Reminder',
 *     body: 'Event "Weekly Meeting" is starting soon...',
 *     category: 'Upcoming Events',
 *
 *     // We'll use the 'customData' field to store metadata about the event
 *     customData: {eventId: '12345'},
 *
 *     // We want the user clicking the notification to open the associated event, so register an 'onSelect' action
 *     onSelect: {task: 'view-calendar-event', target: 'popup'},
 *
 *     buttons: [
 *         // A button that will schedule another reminder for 5 minutes from now. Since the application will be
 *         // responsible for snoozing the event, it will need to know about the user clicking this button. By setting
 *         // a NotificationActionResult for 'onClick', the service will raise a "notification-action" event when this
 *         // button is clicked, and will pass the value of 'onClick' as the 'result' field within the event
 *         {
 *             title: 'Snooze for 5 minutes',
 *             iconUrl: 'https://www.example.com/timer.png',
 *             onClick: {
 *                 task: 'schedule-reminder',
 *                 intervalMs: 5 * 60 * 1000
 *             }
 *         },
 *
 *         // A button that closes the notification and doesn't prompt the user about this event again. Since the
 *         // application doesn't need to do anything when the user clicks this button, we leave 'onClick' undefined
 *         // rather than specifying a NotificationActionResult. This means that no action will be raised when the
 *         // button is clicked, and hence no "notification-action" event will be fired
 *         {
 *             title: 'Dismiss',
 *             iconUrl: 'https://www.example.com/cancel.png'
 *         }
 *     ]
 * });
 *
 * // Create a listener that will be called for each action
 * // Note: This handler will be used for ALL actions, from ALL notifications that are created by this application.
 * addEventListener('notification-action', (event: NotificationActionEvent) => {
 *     const {result, notification} = event;
 *
 *     if (result['task'] === 'view-calendar-event') {
 *         // Open a window with full details of the associated event
 *         openEventDetails(notification.customData.eventId, result['target']);
 *     } else if (result['task'] === 'schedule-reminder') {
 *         // Schedule a new notification
 *         scheduleReminder(notification.customData.eventId, Date.now() + result['intervalMs']);
 *     } // Etc...
 * });
 * ```
 *
 * The example above uses `customData` to store details about the notification subject (in this case, a calendar
 * event), and `onClick` actions to inform the application about how it should respond when the user interacts with the
 * notification. This is our intended usage and recommended best-practice, but the service doesn't require applications
 * to follow this convention - application developers are free to decide how to manage notification state.
 *
 * Within the `notification-action` handler, the application must be able to understand which notification is being
 * handled, and how to decide what it should do next. The example above uses an application-defined `action` field to
 * determine the correct action, but the notification's `id`, `category`, `customData` and other fields are also useful
 * selectors.
 *
 * @module Actions
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActionNoopType = exports.ActionTrigger = void 0;
/**
 * Lists the different triggers that can raise an {@link Actions|action}. Each action that is raised will result in a
 * {@link NotificationActionEvent|`notification-action`} event, which can be captured by the application that created
 * the notification.
 */
var ActionTrigger;
(function (ActionTrigger) {
    /**
     * The user interacted with one of the controls within the notification. This currently means a button click, but
     * other control types will be added in future releases.
     */
    ActionTrigger["CONTROL"] = "control";
    /**
     * The user clicked the body of the notification itself. Any clicks of the notification that don't hit a control
     * or the close button will fire an event with the `'select'` action trigger.
     */
    ActionTrigger["SELECT"] = "select";
    /**
     * The notification was closed, either by user interaction, programmatically by an application, or by the notification expiring.
     */
    ActionTrigger["CLOSE"] = "close";
    /**
     * The notification expired.
     */
    ActionTrigger["EXPIRE"] = "expire";
    /**
     * The action was triggered programmatically by an application.
     *
     * *Not currently supported - will be implemented in a future release*
     */
    ActionTrigger["PROGRAMMATIC"] = "programmatic";
})(ActionTrigger = exports.ActionTrigger || (exports.ActionTrigger = {}));
/**
 * Noop action types see {@link ActionNoop|ActionNoop}.
 */
var ActionNoopType;
(function (ActionNoopType) {
    /**
     * No event will be raised and no dismissal of the notification on action.
     */
    ActionNoopType["EVENT_DISMISS"] = "event_dismiss";
    /**
     * No event will be raised, but the notification will be dismissed on action.
     */
    // EVENT = 'event',
    /**
     * No dismissal of the notification, but the action event will be raised on action.
     */
    // DISMISS = 'dismiss',
})(ActionNoopType = exports.ActionNoopType || (exports.ActionNoopType = {}));


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @hidden
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEventRouter = exports.tryServiceDispatch = exports.getServicePromise = exports.eventEmitter = void 0;
/**
 * File contains vars used to establish service connection between client and provider.
 *
 * These are separated out from 'internal.ts' as including these from provider code will cause the provider to connect
 * to itself.
 *
 * These types are a part of the client, but are not required by applications wishing to interact with the service.
 * This file is excluded from the public-facing TypeScript documentation.
 */
const events_1 = __webpack_require__(7);
const openfin_service_async_1 = __webpack_require__(3);
const internal_1 = __webpack_require__(0);
const EventRouter_1 = __webpack_require__(9);
/**
 * The event emitter to emit events received from the service.  All addEventListeners will tap into this.
 */
exports.eventEmitter = new events_1.EventEmitter();
/**
 * Promise to the channel object that allows us to connect to the client
 */
let channelPromise;
const hasDOMContentLoaded = new openfin_service_async_1.DeferredPromise();
let reconnect = false;
const MIN_API_VERSION = 53;
if (typeof fin !== 'undefined') {
    launchSystemApp();
    getServicePromise();
    if (document.readyState !== 'loading') {
        hasDOMContentLoaded.resolve();
    }
    else {
        window.addEventListener('DOMContentLoaded', () => {
            hasDOMContentLoaded.resolve();
        });
        document.addEventListener('DOMContentLoaded', () => {
            hasDOMContentLoaded.resolve();
        });
    }
}
async function launchSystemApp() {
    if (!window.navigator.appVersion.includes('Windows')) {
        // Mac has an RVM now
        fin.System.openUrlWithBrowser('fins://system-apps/notification-center');
        return;
    }
    try {
        const info = await fin.System.getRvmInfo();
        const major = parseInt(info.version.split('.')[0]);
        if (major >= 6) {
            // @ts-ignore
            if (fin.System.launchManifest) {
                // Launch with no ui in newer runtimes that support the `launchManifest` api.
                // @ts-ignore
                fin.System.launchManifest('fins://system-apps/notification-center', { noUi: true }).catch((error) => {
                    console.error('Unable to launch the Notification Center as a system app', error);
                });
            }
            else {
                // Fallback to launching with ui
                fin.System.openUrlWithBrowser('fins://system-apps/notification-center').catch(() => { });
            }
        }
    }
    catch (e) {
        // Do nothing
    }
}
async function getServicePromise() {
    var _a, _b;
    await hasDOMContentLoaded.promise;
    if (!channelPromise) {
        if (typeof fin === 'undefined') {
            const msg = 'fin is not defined. The openfin-notifications module is only intended for use in an OpenFin application.';
            channelPromise = Promise.reject(new Error(msg));
            return channelPromise;
        }
        // You can't use an `await` here. If you do, you introduce a race condition that makes this function non-reentrant, and you end
        // up with multiple connections to the provider. So don't do that.
        fin.System.getVersion().then((v) => {
            const apiVersion = parseInt(v.split('.')[2]);
            if (apiVersion < MIN_API_VERSION) {
                console.warn(`API version ${apiVersion} of OpenFin version ${v} is less than ${MIN_API_VERSION}. Please upgrade the runtime version.`);
            }
        });
        // @ts-ignore fin.me has no types yet
        const { name, uuid } = (_b = (_a = fin.me) === null || _a === void 0 ? void 0 : _a.identity) !== null && _b !== void 0 ? _b : fin.Window.me;
        if (uuid === internal_1.SERVICE_IDENTITY.uuid && name === internal_1.SERVICE_IDENTITY.name) {
            // Currently a runtime bug when provider connects to itself. Ideally the provider would never import a file
            // that includes this, but for now it is easier to put a guard in place.
            channelPromise = Promise.reject(new Error('Trying to connect to provider from provider'));
        }
        else {
            const timeoutHandle = window.setTimeout(() => {
                console.warn('Taking a long time to connect to Notifications service. Is the Notifications service running?');
            }, 5000);
            channelPromise = fin.InterApplicationBus.Channel.connect(internal_1.SERVICE_CHANNEL, {
                wait: true,
                payload: { version: '1.9.1' },
            }).then((channel) => {
                window.clearTimeout(timeoutHandle);
                const eventRouter = getEventRouter();
                // Register service listeners
                channel.register('WARN', (payload) => console.warn(payload));
                channel.register('event', (event) => {
                    eventRouter.dispatchEvent(event);
                });
                // Any unregistered action will simply return false
                channel.setDefaultAction(() => false);
                channel.onDisconnection(() => {
                    console.warn('Disconnected from Notifications service');
                    reconnect = true;
                    channelPromise = null;
                    // Relaunch notifications incase it was launched as a service first
                    launchSystemApp();
                    setTimeout(() => {
                        console.log('Attempting to reconnect to Notifications service');
                        getServicePromise();
                    }, 300);
                });
                if (reconnect) {
                    console.log('Reconnected to Notifications service');
                }
                else {
                    console.log('Connected to Notifications service');
                }
                return channel;
            });
        }
    }
    return channelPromise;
}
exports.getServicePromise = getServicePromise;
/**
 * Wrapper around service.dispatch to help with type checking
 * @param action Action type.
 * @param payload Data payload to send to the provider.
 */
async function tryServiceDispatch(action, payload) {
    const channel = await getServicePromise();
    return channel.dispatch(action, payload);
}
exports.tryServiceDispatch = tryServiceDispatch;
let eventRouter;
function getEventRouter() {
    if (!eventRouter) {
        eventRouter = new EventRouter_1.EventRouter(exports.eventEmitter);
    }
    return eventRouter;
}
exports.getEventRouter = getEventRouter;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(8));
__export(__webpack_require__(4));


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class DeferredPromise {
    constructor() {
        const promise = new Promise((res, rej) => {
            this._resolve = res;
            this._reject = rej;
        });
        this._promise = promise;
    }
    get promise() {
        return this._promise;
    }
    get resolve() {
        return this._resolve;
    }
    get reject() {
        return this._reject;
    }
}
exports.DeferredPromise = DeferredPromise;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * These are the templates you can use.
 *
 * @module Templates
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TemplateNames = void 0;
exports.TemplateNames = {
    markdown: 'markdown',
    list: 'list',
};


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable no-redeclare */
/**
 * @module NotificationCenter
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNotificationsCount = exports.toggleNotificationCenter = exports.clearAll = exports.getAll = exports.clear = exports.create = exports.removeEventListener = exports.addEventListener = exports.VERSION = exports.NotificationIndicatorType = exports.NotificationIndicator = exports.NotificationOptions = exports.provider = void 0;
/**
 * Need a comment block here so that the comment block above is interpreted as a file comment, and not a comment on the
 * import below.
 *
 * @hidden
 */
const actions_1 = __webpack_require__(1);
const connection_1 = __webpack_require__(2);
const internal_1 = __webpack_require__(0);
const provider = __importStar(__webpack_require__(10));
exports.provider = provider;
const validation_1 = __webpack_require__(12);
const indicator_1 = __webpack_require__(13);
Object.defineProperty(exports, "NotificationIndicator", { enumerable: true, get: function () { return indicator_1.NotificationIndicator; } });
Object.defineProperty(exports, "NotificationIndicatorType", { enumerable: true, get: function () { return indicator_1.IndicatorType; } });
const templates_1 = __webpack_require__(5);
Object.defineProperty(exports, "NotificationOptions", { enumerable: true, get: function () { return templates_1.NotificationOptions; } });
__exportStar(__webpack_require__(1), exports);
__exportStar(__webpack_require__(14), exports);
__exportStar(__webpack_require__(15), exports);
__exportStar(__webpack_require__(16), exports);
__exportStar(__webpack_require__(19), exports);
__exportStar(__webpack_require__(20), exports);
/**
 * The Notification Client library's version in semver format.
 *
 * This is the version which you are currently using.
 */
exports.VERSION = '1.9.1';
const eventHandler = connection_1.getEventRouter();
function parseEventWithNotification(event) {
    const { notification } = event;
    return Object.assign(Object.assign({}, event), { notification: Object.assign(Object.assign({}, notification), { date: new Date(notification.date), expires: notification.expires !== null ? new Date(notification.expires) : null }) });
}
eventHandler.registerDeserializer('notification-created', (event) => {
    return parseEventWithNotification(event);
});
eventHandler.registerDeserializer('notification-closed', (event) => {
    return parseEventWithNotification(event);
});
eventHandler.registerDeserializer('notification-action', (event) => {
    const _a = parseEventWithNotification(event), { controlSource, controlIndex } = _a, rest = __rest(_a, ["controlSource", "controlIndex"]);
    if (event.trigger === actions_1.ActionTrigger.CONTROL) {
        const control = event.notification[controlSource][controlIndex];
        return Object.assign(Object.assign({}, rest), { control });
    }
    else {
        return rest;
    }
});
eventHandler.registerDeserializer('notifications-count-changed', (event) => {
    return event;
});
/**
 * Adds a listener, see definitions of individual event interfaces for details on each event.
 *
 * @param eventType The event being subscribed to
 * @param listener The callback function to add
 */
function addEventListener(eventType, listener) {
    validation_1.validateEnvironment();
    eventType = validation_1.sanitizeEventType(eventType);
    listener = validation_1.sanitizeFunction(listener);
    const count = connection_1.eventEmitter.listenerCount(eventType);
    connection_1.eventEmitter.addListener(eventType, listener);
    if (count === 0 && connection_1.eventEmitter.listenerCount(eventType) === 1) {
        connection_1.tryServiceDispatch(internal_1.APITopic.ADD_EVENT_LISTENER, eventType);
    }
}
exports.addEventListener = addEventListener;
/**
 * Removes a listener previously added with {@link addEventListener}.
 *
 * Has no effect if `listener` isn't a callback registered against `eventType`.
 *
 * @param eventType The event being unsubscribed from
 * @param listener The callback function to remove, must be strictly-equal (`===` equivilance) to a listener previously passed to {@link addEventListener} to have an effect
 */
function removeEventListener(eventType, listener) {
    validation_1.validateEnvironment();
    eventType = validation_1.sanitizeEventType(eventType);
    listener = validation_1.sanitizeFunction(listener);
    const count = connection_1.eventEmitter.listenerCount(eventType);
    connection_1.eventEmitter.removeListener(eventType, listener);
    if (count === 1 && connection_1.eventEmitter.listenerCount(eventType) === 0) {
        connection_1.tryServiceDispatch(internal_1.APITopic.REMOVE_EVENT_LISTENER, eventType);
    }
}
exports.removeEventListener = removeEventListener;
/**
 * Creates a new notification.
 *
 * The notification will appear in the Notification Center and as a toast if the Center is not visible.
 *
 * If a notification is created with an `id` of an already existing notification, the existing notification will be recreated with the new content.
 *
 * ```ts
 * import {create} from 'openfin-notifications';
 *
 * create({
 *      id: 'uniqueNotificationId',
 *      title: 'Notification Title',
 *      body: 'Text to display within the notification body',
 *      category: 'Sample Notifications',
 *      icon: 'https://openfin.co/favicon.ico'
 * });
 * ```
 *
 * @param options Notification configuration options.
 */
async function create(options) {
    // Most validation logic is handled on the provider, but need an early check here
    // as we call date.valueOf when converting into a CreatePayload
    if (typeof options !== 'object' || options === null) {
        throw new Error('Invalid argument passed to create: argument must be an object and must not be null');
    }
    if (options.date !== undefined && !(options.date instanceof Date)) {
        throw new Error('Invalid argument passed to create: "date" must be a valid Date object');
    }
    if (options.expires !== undefined &&
        options.expires !== null &&
        !(options.expires instanceof Date)) {
        throw new Error('Invalid argument passed to create: "expires" must be null or a valid Date object');
    }
    const response = await connection_1.tryServiceDispatch(internal_1.APITopic.CREATE_NOTIFICATION, Object.assign(Object.assign({}, options), { date: options.date && options.date.valueOf(), expires: options.expires && options.expires.valueOf() }));
    return Object.assign(Object.assign({}, response), { date: new Date(response.date), expires: response.expires !== null ? new Date(response.expires) : null });
}
exports.create = create;
/**
 * Clears a specific notification from the Notification Center.
 *
 * Returns true if the notification was successfully cleared.  Returns false if the notification was not cleared, without errors.
 *
 * ```ts
 * import {clear} from 'openfin-notifications';
 *
 * clear('uniqueNotificationId');
 * ```
 *
 * @param id ID of the notification to clear.
 */
async function clear(id) {
    // Should have some sort of input validation here...
    return connection_1.tryServiceDispatch(internal_1.APITopic.CLEAR_NOTIFICATION, { id });
}
exports.clear = clear;
/**
 * Retrieves all Notifications which were created by the calling application, including child windows.
 *
 * ```ts
 * import {getAll} from 'openfin-notifications'
 *
 * getAll().then((notifications: Notification[]) => {
 *     console.log(`Service has ${notifications.length} notifications for this app:`, notifications);
 * });
 * ```
 *
 * There is deliberately no mechanism provided for fetching notifications that were created by a different application.
 */
async function getAll() {
    // Should have some sort of input validation here...
    const response = await connection_1.tryServiceDispatch(internal_1.APITopic.GET_APP_NOTIFICATIONS, undefined);
    return response.map((note) => {
        return Object.assign(Object.assign({}, note), { indicator: note.indicator || null, date: new Date(note.date), expires: note.expires !== null ? new Date(note.expires) : null });
    });
}
exports.getAll = getAll;
/**
 * Clears all Notifications which were created by the calling application, including child windows.
 *
 * Returns the number of successfully cleared Notifications.
 *
 * ```ts
 * import {clearAll} from 'openfin-notifications';
 *
 * clearAll();
 * ```
 */
async function clearAll() {
    // Should have some sort of input validation here...
    return connection_1.tryServiceDispatch(internal_1.APITopic.CLEAR_APP_NOTIFICATIONS, undefined);
}
exports.clearAll = clearAll;
/**
 * Toggles the visibility of the Notification Center.
 *
 * ```ts
 * import {toggleNotificationCenter} from 'openfin-notifications';
 *
 * toggleNotificationCenter();
 * ```
 */
async function toggleNotificationCenter() {
    return connection_1.tryServiceDispatch(internal_1.APITopic.TOGGLE_NOTIFICATION_CENTER, undefined);
}
exports.toggleNotificationCenter = toggleNotificationCenter;
/**
 * Get the total count of notifications from **all** applications.
 *
 * ```ts
 * import {getNotificationsCount} from 'openfin-notifications';
 *
 * getNotificationsCount();
 * ```
 */
async function getNotificationsCount() {
    return connection_1.tryServiceDispatch(internal_1.APITopic.GET_NOTIFICATIONS_COUNT, undefined);
}
exports.getNotificationsCount = getNotificationsCount;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const DeferredPromise_1 = __webpack_require__(4);
async function serialForEach(arr, asyncF) {
    let i = 0;
    for (const x of arr) {
        await asyncF(x, i, arr);
        i++;
    }
}
exports.serialForEach = serialForEach;
async function serialMap(arr, asyncF) {
    const result = [];
    await serialForEach(arr, async (x, i, r) => {
        result.push(await asyncF(x, i, r));
    });
    return result;
}
exports.serialMap = serialMap;
async function serialFilter(arr, asyncF) {
    const result = [];
    await serialForEach(arr, async (x, i, r) => {
        if (await asyncF(x, i, r)) {
            result.push(x);
        }
    });
    return result;
}
exports.serialFilter = serialFilter;
async function parallelForEach(arr, asyncF) {
    await Promise.all(arr.map(asyncF));
}
exports.parallelForEach = parallelForEach;
async function parallelMap(arr, asyncF) {
    const result = [];
    await parallelForEach(arr, async (x, i, r) => {
        result[i] = await asyncF(x, i, r);
    });
    return result;
}
exports.parallelMap = parallelMap;
async function parallelFilter(arr, asyncF) {
    const table = [];
    await parallelForEach(arr, async (x, i, r) => {
        table[i] = await asyncF(x, i, r);
    });
    return arr.filter((x, i) => table[i]);
}
exports.parallelFilter = parallelFilter;
/**
 * Races a given promise against a timeout, and either resolves to the value the the promise resolved it, if it resolved before the
 * timeout, or rejects.
 *
 * @param timeoutMs Timeout period in ms
 * @param promise Promise to race against the timeout
 */
function withStrictTimeout(timeoutMs, promise, rejectMessage) {
    const timeout = new Promise((res, rej) => setTimeout(() => rej(new Error(rejectMessage)), timeoutMs));
    return allowReject(Promise.race([timeout, promise]));
}
exports.withStrictTimeout = withStrictTimeout;
/**
 * Races a given promise against a timeout, and resolves to a `[didTimeout, value?]` tuple indicating
 * whether the timeout occurred, and the value the promise resolved to (if timeout didn't occur).
 *
 * @param timeoutMs Timeout period in ms
 * @param promise Promise to race against the timeout
 */
function withTimeout(timeoutMs, promise) {
    const timeout = new Promise((res) => setTimeout(() => res([true, undefined]), timeoutMs));
    const p = promise.then((value) => [false, value]);
    return Promise.race([timeout, p]);
}
exports.withTimeout = withTimeout;
/**
 * Returns a promise that resolves when the given predicate is true, evaluated immediately and each time the provided signal is fired.
 *
 * @param signal When this signal is fired, the predicate is revaluated
 * @param predicate The predicate to evaluate
 * @param guard A promise. If this rejects, give up listening to the signal and reject
 */
function untilTrue(signal, predicate, guard) {
    if (predicate()) {
        return Promise.resolve();
    }
    return untilSignal(signal, predicate, guard);
}
exports.untilTrue = untilTrue;
/**
 * Returns a promise that resolves when the given signal is fired, and the given predicate evaluates to true when passed the arguments
 * recevied from the signal.
 *
 * @param signal The signal to listen to
 * @param predicate The predicate to evaluate against arguments received from the signal
 * @param guard A promise. If this rejects, give up listening to the signal and reject
 */
function untilSignal(signal, predicate, guard) {
    const promise = new DeferredPromise_1.DeferredPromise();
    const slot = signal.add((...args) => {
        if (predicate(...args)) {
            slot.remove();
            promise.resolve();
        }
    });
    if (guard) {
        guard.catch((e) => {
            slot.remove();
            promise.reject(e);
        });
    }
    return allowReject(promise.promise);
}
exports.untilSignal = untilSignal;
/**
 * Attaches an empty `catch` block to a promise, then returns the original promise. This prevents rejection of the promise being logged as
 * a warning during tests, but does not otherwise change behaviour should the promise reject. This should be called for promises we expect
 * to reject under normal circumstances, but would not otherwise have a `catch` block attached.
 *
 * @param promise The promise to attach the catch block to
 */
function allowReject(promise) {
    promise.catch(() => { });
    return promise;
}
exports.allowReject = allowReject;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @hidden
 */
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventRouter = void 0;
/**
 * Class for helping take events that have arrived at the client via the IAB channel, and dispatching them on the correct client-side object
 */
class EventRouter {
    constructor(defaultEmitter) {
        this._emitterProviders = {};
        this._deserializers = {};
        this._defaultEmitter = defaultEmitter;
    }
    registerEmitterProvider(targetType, emitterProvider) {
        this._emitterProviders[targetType] = emitterProvider;
    }
    registerDeserializer(eventType, deserializer) {
        this._deserializers[eventType] = deserializer;
    }
    dispatchEvent(event) {
        const { type, target } = event, rest = __rest(event, ["type", "target"]);
        let emitter;
        if (!target) {
            throw new Error('Invalid event, no target specified');
        }
        else if (target === 'default') {
            emitter = this._defaultEmitter;
        }
        else if (this._emitterProviders[target.type]) {
            emitter = this._emitterProviders[target.type](target.id);
        }
        else {
            throw new Error(`Invalid target, no provider registered for '${target.type}'`);
        }
        // Need to remove 'target' from event before emitting event
        const inputEvent = Object.assign({ type }, rest);
        // Also run through any custom deserializer
        const deserializer = this._deserializers[type];
        if (deserializer) {
            emitter.emit(type, deserializer(inputEvent));
        }
        else {
            emitter.emit(type, inputEvent);
        }
    }
}
exports.EventRouter = EventRouter;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @module Provider
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isConnectedToAtLeast = exports.getStatus = void 0;
/**
 * Need a comment block here so that the comment block above is interpreted as a file comment, and not a comment on the
 * import below.
 *
 * @hidden
 */
const semver_compare_1 = __importDefault(__webpack_require__(11));
const openfin_service_async_1 = __webpack_require__(3);
const connection_1 = __webpack_require__(2);
const internal_1 = __webpack_require__(0);
/**
 * Retrieves the connection status and version semver of the Service Provider in the shape of a {@link ProviderStatus} object.
 *
 * If the Provider is connected, its' version number will be supplied in the returned object. If not, `version` will be `null`.
 *
 * ```ts
 * import {provider} from 'openfin-notifications';
 *
 * const status: ProviderStatus = provider.getStatus();
 * console.log(status.connected ? `Conencted to provider (version ${status.version})` : 'Not connected to provider');
 * ```
 *
 * Note: Connection status is only available when the connected provider is verison 0.11.2 or later. For earlier
 * versions, this API will indicate that the provider is disconnected.
 *
 * @since 0.11.2
 */
function getStatus() {
    // We need to race a timeout here as we never reject if the provider is not connected.
    return openfin_service_async_1.withStrictTimeout(500, connection_1.tryServiceDispatch(internal_1.APITopic.GET_PROVIDER_STATUS, undefined), '').catch(() => {
        return {
            connected: false,
            version: null,
        };
    });
}
exports.getStatus = getStatus;
/**
 * Evaluates the provided version against the Providers version.
 *
 * This will return `true` if the Provider version is greater than or equal to the provided version. If not, `false` will be returned.
 *
 * If the Provider is not connected, `false` will be returned.
 *
 * ```ts
 * import {provider, VERSION} from 'openfin-notifications';
 *
 * const hasMatchingProvider: boolean = provider.isConnectedToAtLeast(VERSION);
 * if (!hasMatchingProvider) {
 *     console.warn('Connected to an older provider version. Some functionality may not be available.');
 * }
 * ```
 *
 * Note: Version information is only available when the connected provider is verison 0.11.2 or later. For earlier
 * versions, this API will indicate that the provider is disconnected.
 *
 * @param version Version to compare against the Provider version. This should be in semvar format.
 * @since 0.11.2
 */
async function isConnectedToAtLeast(version) {
    const status = await getStatus();
    if (status.connected && status.version !== null) {
        const compare = semver_compare_1.default(status.version, version);
        if (compare === 0 || compare === 1) {
            return true;
        }
    }
    return false;
}
exports.isConnectedToAtLeast = isConnectedToAtLeast;


/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = function cmp (a, b) {
    var pa = a.split('.');
    var pb = b.split('.');
    for (var i = 0; i < 3; i++) {
        var na = Number(pa[i]);
        var nb = Number(pb[i]);
        if (na > nb) return 1;
        if (nb > na) return -1;
        if (!isNaN(na) && isNaN(nb)) return 1;
        if (isNaN(na) && !isNaN(nb)) return -1;
    }
    return 0;
};


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.safeStringify = exports.validateEnvironment = exports.sanitizeEventType = exports.sanitizeFunction = void 0;
/**
 * Validates and returns the provided function
 */
function sanitizeFunction(value) {
    if (typeof value !== 'function') {
        throw new Error(`Invalid argument passed: ${safeStringify(value, 'The provided value')} is not a valid function`);
    }
    return value;
}
exports.sanitizeFunction = sanitizeFunction;
/**
 * Validates the provided event type
 */
function sanitizeEventType(eventType) {
    if (eventType === 'notification-action' ||
        eventType === 'notification-created' ||
        eventType === 'notification-closed' ||
        eventType === 'notifications-count-changed' ||
        eventType === 'notification-form-submitted') {
        return eventType;
    }
    throw new Error(`Invalid argument passed: ${safeStringify(eventType, 'The provided event type')} is not a valid Notifications event type`);
}
exports.sanitizeEventType = sanitizeEventType;
/**
 * Validates we're running inside an OpenFin environment
 */
function validateEnvironment() {
    if (typeof fin === 'undefined') {
        throw new Error('fin is not defined. The openfin-notifications module is only intended for use in an OpenFin application.');
    }
}
exports.validateEnvironment = validateEnvironment;
function safeStringify(value, fallback) {
    // Provided object may not be stringify-able (e.g., due to circular references), so we need to try-catch
    let result;
    try {
        result = JSON.stringify(value);
    }
    catch (e) {
        result = fallback;
    }
    return result;
}
exports.safeStringify = safeStringify;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @module Notifications
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.IndicatorType = void 0;
/**
 * Lists possible semantic use-cases for notifications, which can alter how the notification is presented to the user.
 *
 * Additional indicator types may be added in future releases.
 */
var IndicatorType;
(function (IndicatorType) {
    IndicatorType["FAILURE"] = "failure";
    IndicatorType["WARNING"] = "warning";
    IndicatorType["SUCCESS"] = "success";
})(IndicatorType = exports.IndicatorType || (exports.IndicatorType = {}));


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Notifications allow additional UI components to be specified by applications. The service will control the
 * positioning and styling of these components.
 *
 * In this version of the service, only buttons are supported. Additional control types will be added in future
 * releases.
 *
 * @module Controls
 */
Object.defineProperty(exports, "__esModule", { value: true });


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @hidden
 */
Object.defineProperty(exports, "__esModule", { value: true });


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(17), exports);
__exportStar(__webpack_require__(18), exports);


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * When you make a form, you provide a list of [[FormFields]]. Each FormField contains the ingredients to make a single widget in the form.
 * The actual definitions of the widgets are derived from [[BaseWidgetSpec]].
 *
 * A FormField contains the type of data, the key to store the user input into [[CustomDataWithForms]], and some additional configuration.
 * @module FormFields
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.FieldType = void 0;
/**
 * Data type of a fields. e.g. string, number
 */
exports.FieldType = {
    string: 'string',
    number: 'number',
    boolean: 'boolean',
    // date = "date"
};


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * These are available widgets for use in forms.
 *
 * @module FormWidgets
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.WidgetType = exports.BooleanWidgetType = exports.NumberWidgetType = exports.StringWidgetType = void 0;
// I have left commented out examples of other widget types to aid
// others in implementing new widgets.
/**
 * The StringWidgetType is how you display a text string.
 */
exports.StringWidgetType = {
    Text: 'Text',
    // TextArea: 'TextArea',
    // Color: 'Color'
};
exports.NumberWidgetType = {
    Number: 'Number',
};
exports.BooleanWidgetType = {
    Toggle: 'Toggle',
    Checkbox: 'Checkbox'
};
exports.WidgetType = Object.assign(Object.assign(Object.assign({}, exports.StringWidgetType), exports.NumberWidgetType), exports.BooleanWidgetType);
// export interface MultiOption<T = unknown> {
//     display?: string;
//     value: T;
// }
// export interface SelectWidget<T = string | number> extends BaseWidget<typeof WidgetType['Select']> {
//     options: MultiOption<T>[];
//     placeholder?: string;
// }
// export interface RadioButtonGroupWidget extends BaseWidget<typeof WidgetType['RadioButtonGroup']> {
//     options: MultiOption[];
//     placeholder?: string;
// }
// export type MultiWidgets = SelectWidget | RadioButtonGroupWidget;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @module Notifications
 */
Object.defineProperty(exports, "__esModule", { value: true });


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(__webpack_require__(21), exports);
__exportStar(__webpack_require__(5), exports);


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Core notification features.
 *
 * @module BaseNotificationOptions
 */
Object.defineProperty(exports, "__esModule", { value: true });


/***/ })
/******/ ]);
});
//# sourceMappingURL=main-bundle.js.map