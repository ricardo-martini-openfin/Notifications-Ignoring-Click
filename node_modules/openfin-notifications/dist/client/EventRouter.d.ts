/**
 * @hidden
 */
/// <reference types="node" />
/**
 * Acts as a central point for routing all events received from the provider.
 */
import { EventEmitter } from 'events';
import { TransportMappings, TransportMemberMappings } from './internal';
export interface EventSpecification {
    type: string;
}
declare type EmitterProvider = (targetId: string) => EventEmitter;
declare type EventDeserializer<E extends EventSpecification, T extends E> = (event: Transport<T>) => T;
interface EventTarget {
    type: string;
    id: string;
}
export declare type Targeted<T extends EventSpecification> = T & {
    /**
     * Indicates which emitter the client should use to dispatch this event.
     *
     * Allows events to be raised from client-side objects that mirror a corresponding provider-side object. If there
     * is no such model of client-side objects, pass `default` to emit the event from a shared top-level/"global" event
     * emitter.
     */
    target: EventTarget | 'default';
};
export declare type Transport<T extends EventSpecification> = TransportMappings<T> extends never ? {
    [K in keyof T]: TransportMemberMappings<T[K]>;
} : TransportMappings<T>;
/**
 * Class for helping take events that have arrived at the client via the IAB channel, and dispatching them on the correct client-side object
 */
export declare class EventRouter<E extends EventSpecification> {
    private readonly _emitterProviders;
    private readonly _deserializers;
    private readonly _defaultEmitter;
    constructor(defaultEmitter: EventEmitter);
    registerEmitterProvider(targetType: string, emitterProvider: EmitterProvider): void;
    registerDeserializer<T extends E>(eventType: T['type'], deserializer: EventDeserializer<E, T>): void;
    dispatchEvent<T extends E>(event: Targeted<Transport<T>>): void;
}
export {};
